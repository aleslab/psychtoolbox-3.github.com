<h2 id="psychtoolbox-psychglimageprocessing">[[Psychtoolbox]] › [[PsychGLImageProcessing]]</h2>
<p><a href="DisplayUndistortionBezier" class="uri">DisplayUndistortionBezier</a>([caliboutfilename] [, xnum=2][, ynum=2][, subdivision=100][, imagename=default][, screenid=max][, stereomode=0][, winrect=[]][, calibinfilename][, refimagename])</p>
<p>Geometric display calibration procedure for geometric undistortion of<br />
distorted displays. Needs graphics hardware with support for PTB imaging<br />
pipeline.</p>
<p>IMPORTANT: While this routine is easy to use, it is also limited! The<br />
Banks Vision Lab (University of California, Berkeley) has contributed a<br />
much more powerful and flexible calibration procedure.</p>
<p>Read “help <a href="DisplayUndistortionBVL" class="uri">DisplayUndistortionBVL</a>” for help and info on that one.</p>
<p>Many display devices, e.g., video beamers and most CRT displays, cause<br />
some amount of spatial distortion to your visual stimuli during display.<br />
Psychtoolbox can “undistort” your visual stimuli for you: At stimulus<br />
onset time, PTB applies a geometric warping transformation to your<br />
stimulus which is meant to counteract or cancel out the geometric<br />
distortion caused by your display device. If both PTB’s warp transform<br />
and the distortion transform of the display match, your stimulus will<br />
show up undistorted on the display device.</p>
<h3 id="for-this-to-work-ptb-needs-two-things">For this to work, PTB needs two things:</h3>
<ol type="1">
<li><p>Recent graphics hardware with support for the PTB imaging pipeline:<br />
See our Wiki for recommendations. However, all ATI cards starting with<br />
Radeon 9500 and all <a href="NVidia" class="uri">NVidia</a> cards of type <a href="GeForce" class="uri">GeForce</a>-FX5200 and later, as<br />
well as the Intel-GMA 950 and later should be able to do it, although<br />
more recent cards will have a higher performance.</p></li>
<li><p>A calibration file that defines the warp transformation to apply. Your<br />
experiment script will load that file into <a href="Screen" class="uri">Screen</a>’s “warp engine” at the<br />
beginning of your experiment.</p></li>
</ol>
<p>This routine allows you to create such a calibration file in an<br />
interactive procedure: It applies some warp transformation, shows the<br />
result on your display, and you can change and tweak the transformation<br />
until it fits your needs, ie. it nicely undistorts your display. Then the<br />
corresponding calibration file is saved for later use with that display.</p>
<p>As the name suggests, <a href="DisplayUndistortionBezier" class="uri">DisplayUndistortionBezier</a> supports a continous<br />
mapping (x’, y’) = Beziersurface(x, y) from input pixel locations (x,y)<br />
in your stimulus image to output locations (x’, y’) on your display. This<br />
mapping is defined by a Bezier surface (see Chapter 12 “Evaluators and<br />
NURBS” or any other textbook about NURBS for a description of their<br />
mathematical properties).</p>
<p>The shape of the Bezier surface is defined by the location of a couple of<br />
control points, which you can move around during the calibration<br />
procedure to modify the shape of the surface. You can select the number<br />
of control points to use: More control points (=degrees of freedom) allow<br />
for more flexibility and finer control, but make the calibration procedure<br />
more tedious for you. Their number doesn’t affect computation time when<br />
your experiment script is running.</p>
<h3 id="how-to-use">How to use:</h3>
<ol type="1">
<li>Start the script, providing all parameters that you don’t want to have<br />
at default settings (all parameters have defaults):</li>
</ol>
<p>‘caliboutfilename’ Name of the file to which calibration results should<br />
be stored. Defaults to ‘BezierCalibdata.mat’ in your current working directory.</p>
<p>‘xnum’ and ‘ynum’ Number of horizontal and vertical control points to<br />
use. Higher numbers mean finer and more flexible control, but also a more<br />
tedious calibration for you. Their number doesn’t affect runtime<br />
behaviour of your stimulus script. For simple trapezoid correction or<br />
translation/rotation, the minimum allowed number of control points xnum=2<br />
and ynum=2 is sufficient - this is the default. For most other purposes<br />
a 3 by 3 grid of control points xnum=3 and ynum=3 may suffice. However,<br />
you are not limited by any upper bound…</p>
<p>‘subdivision’ Number of vertical and horizontal subdivisions of the<br />
bezier surface - the grid resolution: Higher numbers mean higher accuracy<br />
but also higher computational overhead in your script. However, recent<br />
graphics hardware shouldn’t have much problems handling reasonably sized<br />
meshes. Defaults to a 100 by 100 grid.</p>
<p>‘imagename’ Name of the image file for the test image to be rendered as<br />
an alternative to the mesh grid. We default to our standard ‘konintjes’<br />
image.</p>
<p>‘screenid’ screen id of the target display for calibration.<br />
max(<a href="Screen" class="uri">Screen</a>(‘Screens’)) by default.</p>
<p>‘stereomode’ Stereomode for which calibration should be applied: Defaults<br />
to 0 == Mono mode. [6 1] would mean: “Use stereomode 6 (Anaglyph stereo)<br />
and the right-eye view (1)”.</p>
<p>‘winrect’ Size of the calibration window: Defaults to full-screen.</p>
<p>‘calibinfilename’ Defaults to none. If provided, results of a previous<br />
calibration are loaded from file ‘calibinfilename’ instead of starting<br />
from scratch. Useful for incremental calibration.</p>
<ol start="2" type="1">
<li>After startup, the script will display a grid onscreen, which<br />
represents the displayed area after calibration. Your job is to tweak,<br />
shift and bend that grid so that it looks as flat and rectilinear as<br />
possible on your display from the viewpoint of your subject. The grid has<br />
green control points placed at regular intervals. These are the tweakable<br />
points that you can move: Moving these control points will bend the<br />
calibration grid in a smooth fashion, as if the grid would be attached to<br />
the points with some springs.</li>
</ol>
<h3 id="mouse-operation">Mouse operation:</h3>
<p>To select a control point, just move the mouse pointer close to it, then<br />
press a mouse key. The selected control point will change color to yellow<br />
and a yellow line will connect its current position to its original<br />
position in the uncalibrated display.</p>
<p>You can move the point by moving the mouse pointer while keeping the<br />
mouse key pressed.</p>
<h3 id="keys-and-their-meaning">Keys and their meaning:</h3>
<p>You can also move the currently selected control point via the Cursor<br />
keys, at slow speed, or at a faster speed when holding down the shift<br />
key.</p>
<p>Press the ‘space’ key to toggle between grid display and display of the<br />
test image ‘imagename’. A good way to test the calibration would be to<br />
load a screenshot of one of your typical stimuli as image file<br />
‘imagename’.</p>
<p>You finish the calibration and write it into a calibration file by<br />
pressing the <a href="ESCape" class="uri">ESCape</a> key. This will end the calibration script.</p>
<div class="code_header" style="text-align:right;">
<p><span style="float:left;">Path  </span> <span class="counter">Retrieve <a href=
  "https://raw.github.com/Psychtoolbox-3/Psychtoolbox-3/beta/Psychtoolbox/PsychGLImageProcessing/DisplayUndistortionBezier.m">current version from GitHub</a> | View <a href=
  "https://github.com/Psychtoolbox-3/Psychtoolbox-3/commits/beta/Psychtoolbox/PsychGLImageProcessing/DisplayUndistortionBezier.m">changelog</a></span></p>
</div>
<div class="code">
<p><code>Psychtoolbox/PsychGLImageProcessing/DisplayUndistortionBezier.m</code></p>
</div>
