<h2 id="psychtoolbox-psychtests">[[Psychtoolbox]] › [[PsychTests]]</h2>
<p><a href="HighColorPrecisionDrawingTest" class="uri">HighColorPrecisionDrawingTest</a>([testconfig][, maxdepth][, testblocks][, plotit=0])</p>
<p>Test for numeric drawing precision of your graphics card (GPU). Exercises<br />
a number of tests, where some 2D drawing primitive(s) is drawn in some<br />
well defined color, then the content of the framebuffer is read back and<br />
compared against expected results computed via Matlab code in double<br />
precision. The Matlab code emulates the expected behaviour of an ideal<br />
GPU that works at a precision higher than that of any real GPU.<br />
Difference between exptected and actual results is calculated for each<br />
tested pixel location and the maximum error is stored. Each test case<br />
plots that maximum error to the Matlab window. From the maximum error<br />
value, we also derive the maximum bitdepths of an output device for which<br />
the error would be negligible, ie., the difference would not show up in<br />
any measurable way because the deviation is too small to have any effect<br />
on the display device.</p>
<p>The actual results of the tests depends on a number of conditions like<br />
tested precision range, selected precision of the framebuffer,<br />
alpha-blending mode (if any), texture filtering mode (if textures are<br />
used as drawing primitive), mode of operation of PTB, operating system<br />
etc. For that reason you can specify the exact test conditions via a<br />
number of arguments to this function – Displayed test results will only<br />
be valid for that exact configuration, so if you want to evaluate<br />
suitability of your hardware+OS combo for a given type of visual<br />
stimulus, make sure you choose a test configuration to closely matches<br />
the one used in your stimulus presentation script.</p>
<p>The test itself is currently in a BETA stage! While many of the test<br />
cases seem to work reliably on a variety of tested hardware, there may be<br />
(untested) hardware+OS combos for which the tests display effective<br />
precision numbers that are lower than the ones really achieved by your<br />
hardware – the test is too pessimistic. So USE WITH CARE, DON’T TRUST<br />
THE TEST BLINDLY and APPLY COMMON SENSE when looking at the results.</p>
<h3 id="optional-parameters-and-their-meaning">Optional parameters and their meaning:</h3>
<p>‘testconfig’ is a vector that defines the framebuffer and PTB<br />
configuration to use. All elements have defaults:</p>
<p>Colorclamping (aka high-precision vertex colors vs. standard vertex colors)<br />
-1 / 0 / 1 = Unclamped high-res via shader / Unclamped high-res / Clamped.<br />
Default is 0 == Let PTB auto-select opmode with highest<br />
precision. A setting of -1 overrides PTB’s choice to always<br />
use an internal implementation – If auto-detection works<br />
perfectly this should not give better results than mode 0,<br />
but no automatic is perfect, so it doesn’t hurt to test that<br />
mode. 1 is “low-precision, clamped” mode: It shouldn’t ever<br />
give better results than -1 or 0 and is normally only used<br />
for standard 8 bit precision output of standard stimuli<br />
where bit-accurate output doesnt’ matter too much.</p>
<p>Framebuffer: (aka bit-depth and format of framebuffer)<br />
0 / 1 / 2 / 3/ 4 = 8 bpc fixed, 16bpc float, 32bpc float, 32bpc float<br />
if possible while alpha-blending enabled 16bpc otherwise,<br />
16bpc fixed point (on ATI hardware only).</p>
<pre><code>         Precision with which the framebuffer operates: 8 bpc fixed  
         is a standard 8 bits per precision 256 levels framebuffer.  
         16bpc float allows for an effective 10-11 bit precision,  
         32bpc float allows for an effective 23 bit precision, 16 bpc  
         fixed is only supported on ATI hardware and allows for an  
         effective 16 bit precision, but without alpha-blending  
         support.  

         Selected precision is a accuracy vs. speed &amp; functionality  
         tradeoff. Higher resolution means higher output precision  
         and higher precision for calculation of intermediate  
         results. However it means also more memory usage, slower  
         processing and drawing speed and - on some hardware - it  
         means that alpha-blending and anti-aliasing doesn&#39;t work or  
         works only very slowly. Therefore you need to select a mode  
         that is good enough for your purpose. [Direct3D](Direct3D) 10 compliant  
         hardware from [NVidia](NVidia) and ATI (Geforce 8000 and later, Radeon  
         HD 2000 and later) is supposed to have no relevant  
         limitations wrt. to functionality or precision anymore -- It  
         can carry out all operations including alpha-blending etc.  
         at highest precision (32 bpc float). If you happen to have  
         such hardware then the only reason to choose less than  
         maximum precision is speed -- Lower precision is still  
         processed faster.  

         Please also note that the attainable precision of all the  
         test cases in this script is of course limited by the  
         precision of the framebuffer. E.g., if you chose a 16bpc  
         float framebuffer, none of the tests will be able to attain  
         more than about 10-11 bits of precision.  </code></pre>
<p>Textures: (aka texture precision)<br />
0 / 1 / 2 = 8 bpc fixed, 16bpc float, 32bpc float.</p>
<pre><code>         Precision with which textures are represented -- and  
         ultimately drawn. Same explanations apply as with  
         &#39;Framebuffer&#39;. However, there is no limitation in  
         functionality associated with high texture precision: Should  
         the hardware have some limitations, PTB will work-around  
         them. Higher precision textures still incur higher storage  
         requirements and lower drawing speeds though, so don&#39;t use  
         higher precision than you really need!  </code></pre>
<p>Samplers: (aka texture sampling method)<br />
0 / 1 / 2 = Hardware / PTB-Auto / PTB-Shaders.</p>
<pre><code>         Method employed for texture drawing: PTB-Auto is the  
         preferred choice -- Let PTB auto-select best method for  
         given texture precision and other requirements. However you  
         can manually override to always use PTB-Shaders (built-in  
         workarounds for less capable hardware) or Hardware  
         implementation of your GPU -- usually faster, but maybe less  
         precise.  </code></pre>
<p>Filters: (aka texture filtering method)<br />
0 / 1 = Nearest-Neighbour / Bilinear filtering.</p>
<pre><code>        Method of filtering texture pixels before drawing:  
        Nearest-Neighbour just uses pixels as they are -- blocky or  
        aliased appearance if you draw rotated textures, textures  
        where the &#39;srcRect&#39; and &#39;dstRect&#39; parameters in  
        [Screen](Screen)(&#39;DrawTexture&#39;) don&#39;t exactly match in size, and no way  
        of &quot;scrolling&quot; or positioning textures with subpixel  
        accuracy. However, also no loss in precision due to filtering  
        artifacts caused by low precision filtering hardware.  
        &#39;Bilinear filtering&#39; always provides perfectly anti-aliased  
        and smooth looking textures due to use of bilinear filtering,  
        but may introduce a slight loss of precision if your hardware  
        doesn&#39;t sample accurately. See [DriftTexturePrecisionTest](DriftTexturePrecisionTest) for  
        an extra test of filter accuracy of your GPU.  </code></pre>
<p>‘maxdepth’ parameter: Choose the maximum precision for which the<br />
test-cases test your hardware. Defaults to 16 bits and is restricted to<br />
about 18 bits by the current implementation of this test script. 16 bits<br />
is chosen because there aren’t any display devices with more than 14 bit<br />
output precision available on the market, so 16 bits is “good enough” for<br />
most purposes. Plese note that even if your GPU is able to provide much<br />
more than ‘maxdepth’ bits of precision, the test won’t detect that – it<br />
will only test up to ‘maxdepth’ bits of precision!</p>
<p>‘testblocks’ parameter: A vector of tests to carry out. By default all<br />
tests are carried out and each single test is interruptible by holding<br />
down the left mouse button for a while. However this may take quite long<br />
– dozens of minutes, maybe even over an hour! For that reason you can<br />
specify your own ‘testblocks’ vector to only run a subset of all test<br />
cases and save some time.</p>
<h3 id="the-following-test-cases-are-currently-implemented">The following test cases are currently implemented:</h3>
<p>1 = Test precision of clearing of the framebuffer to selected<br />
‘clearcolor’. ‘clearcolor’ is set in <a href="Screen" class="uri">Screen</a>(‘OpenWindow’) or<br />
<a href="PsychImaging" class="uri">PsychImaging</a>(‘OpenWindow’) etc. or via <a href="Screen" class="uri">Screen</a>(‘FillRect’, window,<br />
clearcolor). Framebuffer clearing is performed after each<br />
<a href="Screen" class="uri">Screen</a>(‘<a href="Flip" class="uri">Flip</a>’) or <a href="Screen" class="uri">Screen</a>(‘FillRect’, window, clearcolor) command and<br />
this test tests precision of that operation.</p>
<p>2 = Test precision of <a href="Screen" class="uri">Screen</a> 2D drawing commands like <a href="FillRect" class="uri">FillRect</a>,<br />
<a href="FrameRect" class="uri">FrameRect</a>, <a href="FillOval" class="uri">FillOval</a>, <a href="FrameOval" class="uri">FrameOval</a>, <a href="DrawLine" class="uri">DrawLine</a> etc.</p>
<p>3 = Test precision of <a href="Screen" class="uri">Screen</a> 2D batch-drawing commands, ie. commands<br />
that allow to draw multiple primitives per command, e.g., <a href="DrawDots" class="uri">DrawDots</a>,<br />
<a href="DrawLines" class="uri">DrawLines</a> and the batch versions of <a href="FillRect" class="uri">FillRect</a>, <a href="FrameRect" class="uri">FrameRect</a>, <a href="FillOval" class="uri">FillOval</a><br />
etc.<br />
Also tests precision of the ‘DrawTexture’ command and of the<br />
built-in gamma correction mechanism of PTB when used with the PTB<br />
imaging pipeline, e.g., in Mono++ or Color++ mode of a CRS Bits++<br />
box.</p>
<p>4 = Test precision of texture drawing commands when the special<br />
‘globalAlpha’ or ‘modulateColor’ arguments are used to modulate the<br />
textures pixel values during drawing – for example for contrast<br />
selection.</p>
<p>5 = Test of precision of alpha-blending: Does use of the alpha-blending<br />
function via <a href="Screen" class="uri">Screen</a>(‘BlendFunction’) introduce any loss of numeric<br />
stimulus precision - and if so, how much?</p>
<pre><code> This testcase 5 is incomplete and under development!  </code></pre>
<p>6 = Test of color precision of text drawing. This only tests to a fixed<br />
precision of 8 bits for 256 levels at the moment, as our the text<br />
renderer doesn’t have a higher precision.</p>
<p>‘plotit’ parameter: If set to 1, output some error plots after tests where it<br />
makes sense. No plotting happens by default.</p>
<div class="code_header" style="text-align:right;">
<p><span style="float:left;">Path  </span> <span class="counter">Retrieve <a href=
  "https://raw.github.com/Psychtoolbox-3/Psychtoolbox-3/beta/Psychtoolbox/PsychTests/HighColorPrecisionDrawingTest.m">current version from GitHub</a> | View <a href=
  "https://github.com/Psychtoolbox-3/Psychtoolbox-3/commits/beta/Psychtoolbox/PsychTests/HighColorPrecisionDrawingTest.m">changelog</a></span></p>
</div>
<div class="code">
<p><code>Psychtoolbox/PsychTests/HighColorPrecisionDrawingTest.m</code></p>
</div>
