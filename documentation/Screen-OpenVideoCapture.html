<h1 id="screenopenvideocapture"><a href="Screen-OpenVideoCapture">Screen(‘OpenVideoCapture’)</a></h1>
<h2 id="psychtoolbox-screen.mexdll-subfunction">[[Psychtoolbox]] › [[Screen]].{mex*,dll} subfunction</h2>
<p>Try to open the video source ‘deviceIndex’ for video capture into onscreen<br />
window ‘windowPtr’ and return a handle ‘videoPtr’ on success. If ‘deviceIndex’<br />
is left out, it defaults to zero - use the first capture device attached to your<br />
machine. You can get a list of all available video capture devices on your<br />
system via a call to <a href="Screen" class="uri">Screen</a>(‘VideoCaptureDevices’). The positive ‘deviceIndex’<br />
values mentioned there can be used to select a specific video capture device.<br />
Certain videocapture devices can’t get auto-detected and are therefore not<br />
addressable this way. For such devices you must find out the type and unique<br />
identifier of the device. Then pass in a negative ‘deviceIndex’ to tell <a href="Screen" class="uri">Screen</a><br />
you want to select a hidden device by its name or id, and pass in the name or id<br />
of that hidden device as string in the argument ‘targetmoviename’. See ‘help<br />
VideoCapture’ for more info.<br />
‘roirectangle’ if specified, defines the requested size for captured images. The<br />
default is to return the maximum size image provided by the capture device. A<br />
‘roirectangle’ setting of [0 0 width height] will not define a region of<br />
interest, but instead request a video capture resolution of width x height<br />
pixels, instead of the default maximum resolution. Settings of [left top right<br />
bottom] will leave video capture at maximum resolution, but crop the images to<br />
the rectangular subregion as defined by the given left, right, top and bottom<br />
borders. Such ROI’s are only applied to returned video images, not to recorded<br />
video by default. See the ‘recordingflags’ settings below on how to adjust this<br />
behaviour to your needs.<br />
The real ROI (region of interest) may differ from the requested one, depending<br />
on the capabilities of your capture device. ‘pixeldepth’ if provided, asks for<br />
the number of layers that captured textures should have: 1=Luminance image,<br />
2=Luminance+Alpha image, 3=RGB image, 4=RGB+Alpha, 5=YCBCR, 6=I420 image.<br />
Default is to take whatever the capture device provides by default. Different<br />
devices support different formats so some of these settings may be ignored. Some<br />
combinations of video capture devices and graphics cards may support a setting<br />
of 5=YCBCR encoding. If they do, then this is an especially efficient way to<br />
handle color images, which may result in lower cpu load and higher framerates. A<br />
format of 6=YUV-I420 should be supported by all modern graphics cards and may<br />
provide some performance benefits, but your mileage may vary. If you need very<br />
fast color image capture, try formats 4, 5 and 6 and see which one gives the<br />
best performance for your setup.<br />
‘numbuffers’ if provided, specifies the number of internal video buffers to use.<br />
It defaults to a value that is optimal for your specific hardware for common<br />
use. ‘allowfallback’ if set to 1, will allow Psychtoolbox to use a less<br />
efficient mode of operation for video capture if your specific hardware or<br />
operating system setup doesn’t allow to use the high-performance mode.<br />
‘allowfallback’ defaults to 1 = Allow fallback path.<br />
‘targetmoviename’ If you provide a filename for this argument, PTB will record<br />
the captured video to the specified movie file on your filesystem. PTB will use<br />
a default video codec for encoding the video stream. If you want to use a<br />
specific codec, you can extend the targetmoviename by a string of format<br />
:<a href="CodecType" class="uri">CodecType</a>=xxx , where xxx is the numeric type id or name of the codec.<br />
Please read ‘help VideoRecording’ for many more options for tweaking the video<br />
recording process via the ‘targetmoviename’ parameter.<br />
‘recordingflags’ specify the behaviour of harddisc-recording and some other<br />
capture operations. Please note that not all flags are supported on all capture<br />
engines, cameras and operating systems. Unsupported flags will be silently<br />
ignored. Most flags are only supported with [<a href="GStreamer" class="uri">GStreamer</a>][(GStreamer)]((GStreamer)) at the moment: 0 (default)<br />
= Only record video. 2 = Record audio track as well. The value 1 (or 1+2) asks<br />
PTB to first record into system memory, and only write the movie file after<br />
capture has been stopped. This allows for higher capture framerates, but is<br />
limited in recording time by installed memory. Also, this mode currently can<br />
sometimes cause hangs and crashes of PTB for unknown reasons, so better avoid!<br />
A setting of 4 will only enable recording, but no return of captured data, i.e.,<br />
just record to disk. A setting of 8 will avoid some calls that are supposed to<br />
provide better realtime behaviour, but may cause some problems with some video<br />
codecs when recording to disk. A setting of 16 will perform most of the heavy<br />
work on a separate parallel background thread, utilizing multi-core machines<br />
better.<br />
A setting of 32 will try to select the highest quality codec for texture<br />
creation from captured video, instead of the normal quality codec. A setting of<br />
64 will return capture timestamps in the time base of the video engine (e.g.,<br />
elapsed time since start of capture, or recording time in movie), instead of the<br />
default time base, which is regular <a href="GetSecs" class="uri">GetSecs</a>() time.<br />
A setting of 128 will force use of a videorate converter in pure live capture<br />
mode. By default the videorate converter is only used if video recording is<br />
active. The converter makes sure that video is recorded (or delivered) at<br />
exactly the requested capture framerate, even if the system isn’t really capable<br />
of maintaining that framerate: If the video source (camera) delivers frames at a<br />
too low framerate, the converter will insert duplicated frames to boost up<br />
effective framerate. If the source delivers more frames than the engine can<br />
handle (e.g., system overload or video encoding too slow) the converter will<br />
drop frames to reduce effective framerate. Slight fluctuations are compensated<br />
by adjusting the capture timestamps. This mechanism guarantees a constant<br />
framerate in recorded video as well as the best possible audio-video sync and<br />
smoothness of video, given system constraints. The downside may be that the<br />
recorded content and returned timestamps don’t reflect the true timing of<br />
capture, but a beautified version. In pure live capture, rate conversion is off<br />
by default to avoid such potential confounds in the timestamps. Choose this<br />
options carefully.<br />
A setting of 256 in combined video live capture and video recording mode will<br />
restrict video framerate conversion to the recorded videostream, but provide<br />
mostly untampered true timing to the live capture. By default, framerate<br />
conversion applies to recording and live feedback if video recording is enabled.<br />
A setting of 512 requests that ROI’s as defined by the ‘roirectangle’ parameter<br />
get also applied to recorded video. Without this setting, ROI’s only apply to<br />
live video as returned by <a href="Screen" class="uri">Screen</a>(‘GetCapturedImage’,…);<br />
A setting of 1024 disables application of ROI’s to live video as returned by<br />
<a href="Screen" class="uri">Screen</a>(‘GetCapturedImage’,…);<br />
A setting of 2048 requests immediate conversion of video textures into a format<br />
suitable as offscreen window, for use with <a href="Screen" class="uri">Screen</a>(‘TransformTexture’) or for<br />
drawing with custom user provided GLSL shaders. Normally this happens<br />
automatically on first use, asking for it explicitely may have performance or<br />
convenience benefits.<br />
A setting of 4096 requests to apply some performance optimizations (the setting<br />
of filter-caps). This can hurt if a videocapture device refuses to work, with<br />
some error message about ‘’check your filtered caps, if any.’’. By default, if<br />
the flag is omitted, some performance loss will be present, but capture will be<br />
more robust with problematic cameras.</p>
<p>‘captureEngineType’ This optional parameter allows selection of the video<br />
capture engine to use for this video source. Allowable values are currently 1<br />
and 3. A value of 1 selects Firewire video capture via the free software library<br />
libdc1394-V2. That engine only supports high performance machine vision cameras<br />
that are compliant with the IIDC-1.x standard and are connected via a Firewire<br />
(IEEE-1394) bus system. Use of the engine with such cams allows for much higher<br />
flexibility and performance than use of video capture via [<a href="GStreamer" class="uri">GStreamer</a>][(GStreamer)]((GStreamer)), however one<br />
restriction is that sound recording isn’t yet supported with firewire capture.<br />
The firewire capture engine is supported on Linux and <a href="MacOS" class="uri">MacOS</a>/X, but not on<br />
MS-Windows.</p>
<p>A value of 3 selects the [<a href="GStreamer" class="uri">GStreamer</a>][(GStreamer)]((GStreamer)) video capture engine. This engine is<br />
supported on all operating systems and allows for video and sound recording of<br />
captured video and audio streams. Type ‘help [<a href="GStreamer" class="uri">GStreamer</a>][(GStreamer]((GStreamer))’ for installation and<br />
setup instructions for the required [<a href="GStreamer" class="uri">GStreamer</a>][(GStreamer)]((GStreamer)) runtime libraries.</p>
<p>If you don’t specify ‘captureEngineType’, the global setting from<br />
<a href="Screen" class="uri">Screen</a>(‘<a href="Preference" class="uri">Preference</a>’, ‘DefaultVideoCaptureEngine’) will be used. If you don’t<br />
specify that either then engine selection will default to [<a href="GStreamer" class="uri">GStreamer</a>][(GStreamer)]((GStreamer)).</p>
<p>To summarize:<br />
[<a href="GStreamer" class="uri">GStreamer</a>][(GStreamer)]((GStreamer)): Is the engine of choice for all operating systems and with most<br />
standard applications.<br />
Firewire engine: Supports only Firewire machine vision cameras, but allows free<br />
selection among all connected cameras, simultaneous operation of many cameras,<br />
low latency, high framerates and reliability, precise timestamping and low level<br />
access to many special features of such cameras, e.g., gain-, shutter-,<br />
exposure-, trigger controls etc.</p>
<p>‘bitdepth’ Optional parameter to ask for video capture in a certain color or<br />
luminance resolution, a certain number of bits per color or luminance component,<br />
also known as bpc. Defaults to 8 bpc if omitted, ie., 8 bits or 1 Byte<br />
resolution per luminance or color channel for classic 256 levels of intensity.<br />
Lower values are unsupported and will get rounded up to 8 bpc. Higher values may<br />
be supported by some higher end professional class cameras. If you ask for an<br />
unsupported value, the engine will try to get the lowest supported value that<br />
matches or exceeds what you want. Currently the firewire engine for pro-class<br />
IIDC compliant firewire or USB machine vision cameras supports bitdepth &gt; 8 bpc<br />
on capable cameras. The [<a href="GStreamer" class="uri">GStreamer</a>][(GStreamer)]((GStreamer)) engine always supports 8 bpc and it may<br />
support 16 bpc on capable cameras. Please note that requesting &gt; 8 bpc will<br />
cause a substantial increase in both video bus bandwidth and memory consumption:<br />
Twice the bus bandwidth and two to four times the amount of memory per video<br />
frame, so tread carefully.</p>
<p>&lt;&lt;=====See also:===== CloseVideoCapture StartVideoCapture StopVideoCapture GetCapturedImage &lt;&lt;</p>
