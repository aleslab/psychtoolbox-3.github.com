<h1 id="screenbeginopengl"><a href="Screen-BeginOpenGL">Screen(‘BeginOpenGL’)</a></h1>
<h2 id="psychtoolbox-screen.mexdll-subfunction">[[Psychtoolbox]] › [[Screen]].{mex*,dll} subfunction</h2>
<p>Prepare window ‘windowPtr’ for <a href="OpenGL" class="uri">OpenGL</a> rendering by external <a href="OpenGL" class="uri">OpenGL</a> code. This<br />
allows to use <a href="OpenGL" class="uri">OpenGL</a> drawing routines other than the ones implemented in<br />
<a href="Screen" class="uri">Screen</a>() to draw to a Psychtoolbox onscreen- or offscreen window via execution<br />
of <a href="OpenGL" class="uri">OpenGL</a> commands. Typical clients of this function are mogl (Richard F.<br />
Murrays <a href="OpenGL" class="uri">OpenGL</a> for Matlab wrapper), the new Eyelink-Toolbox and third party<br />
Matlab Mex-Files which contain <a href="OpenGL" class="uri">OpenGL</a> rendering routines. You *have to* call<br />
this command once before using any of those external drawing commands for the<br />
window. After drawing, you *must* switch back to PTB’s rendering via the<br />
<a href="Screen" class="uri">Screen</a>(‘EndOpenGL’, windowPtr); command. Normally, you won’t provide the<br />
optional flag ‘sharecontext’, so PTB will automatically isolate the <a href="OpenGL" class="uri">OpenGL</a> state<br />
of your code from its internal state. However, if you provide sharecontext=1,<br />
then PTB will allow your code to use and affect <a href="PTBs" class="uri">PTBs</a> internal context. Only do<br />
this if you really know what you’re doing! If you provide sharecontext=2 then<br />
PTB will give you your own private context, but it will synchronize the state of<br />
that context with its internal state - Seldomly needed, but here for your<br />
convenience. Caution: sharecontext=2 is not supported on all operating systems<br />
and gpu’s, e.g., not on OSX, so avoid if you can! The context state isolation is<br />
as strict as possible without seriously affecting performance and functionality:<br />
All <a href="OpenGL" class="uri">OpenGL</a> context state is separated, with two exceptions: The framebuffer<br />
binding (if any) is always synchronized with PTB (and reset to zero when calling<br />
‘EndOpenGL’ or another <a href="Screen" class="uri">Screen</a> command) to allow external code to transparently<br />
render into <a href="PTBs" class="uri">PTBs</a> internal framebuffers - Needed for the imaging pipeline to<br />
work. Ressources like textures, display lists, <a href="FBOs" class="uri">FBOs</a>, <a href="VBOs" class="uri">VBOs</a>, <a href="PBOs" class="uri">PBOs</a> and GLSL shaders<br />
are shared between PTB and your code as well for efficiency reasons. Both types<br />
of ressource sharing shouldn’t be a problem, because either you are a beginner<br />
or advanced <a href="OpenGL" class="uri">OpenGL</a> programmer and won’t use those facilities anyway, or you are<br />
an expert user - in which case you’ll know how to prevent any conflicts easily.</p>
<p>&lt;&lt;=====See also:===== EndOpenGL SetOpenGLTexture GetOpenGLTexture moglcore &lt;&lt;</p>
