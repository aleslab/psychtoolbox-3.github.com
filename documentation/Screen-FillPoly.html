<h1 id="screenfillpoly"><a href="Screen-FillPoly">Screen(‘FillPoly’)</a></h1>
<h2 id="psychtoolbox-screen.mexdll-subfunction">[[Psychtoolbox]] › [[Screen]].{mex*,dll} subfunction</h2>
<p>Fill polygon. “color” is the clut index (scalar or [r g b] or [r g b a] vector)<br />
that you want to poke into each pixel; default produces white. “pointList” is a<br />
matrix: each row specifies the (x,y) coordinates of a vertex.<br />
The optional flag ‘isConvex’ allows you to tell the routine if the polygon is<br />
convex, (value of 1) or if it is concave (value of 0), allowing the routine to<br />
skip the test for convexity, thereby saving a bit of computation time in timing<br />
sensitive scripts.<br />
Drawing filled polygons is a rather compute intense and slow operation. In<br />
general, drawing convex polygons is pretty fast, drawing concave, but not<br />
self-intersecting polygons is much slower (&gt; 30x slower), and drawing concave<br />
self-intersecting polygons is extremely slow, e.g. &gt; 2000 times slower. If you<br />
have to draw very irregular polygons with may points, it might be a good idea to<br />
preprocess them in some way and maybe break them up into a sequence of more<br />
convex/regular polygons before submitting them to ‘FillPoly’. Or you may want to<br />
use some custom written drawing function for your purpose which is optimized for<br />
drawing your type of polygons.</p>
<p>&lt;&lt;=====See also:===== FramePoly &lt;&lt;</p>
