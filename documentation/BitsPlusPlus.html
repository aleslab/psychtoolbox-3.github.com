<h2 id="psychtoolbox-psychglimageprocessing">[[Psychtoolbox]] › [[PsychGLImageProcessing]]</h2>
<p><a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(cmd [, arg1][, arg2, …]) – Psychtoolbox interface to<br />
Cambridge Research Systems Bits++ and Bits# boxes for high precision<br />
stimulus output to analog displays via 14 bit video converters.</p>
<p>This function is used to set up and interface with the Bits++ / Bits# box of<br />
CRS. It is a Matlab wrapper around lower level GLSL Psychtoolbox<br />
functions. This function depends on graphics hardware that supports the<br />
Psychtoolbox imaging pipeline and framebuffers with more than 14 bit<br />
precision, i.e., 16 bpc fixed point framebuffers or floating point<br />
framebuffers. Have a look at the Psychtoolbox Wiki where you can find a<br />
list of graphics cards with the neccessary features.</p>
<p>This function supersedes the old Matlab based Bits++ Toolbox, which<br />
essentially provides the same functionality on any graphics card, but is<br />
harder to use, much slower and not fully integrated into PTB, ie, you<br />
can’t take full advantage of PTB’s advanced drawing and image processing<br />
functions when using the old Bits++ toolbox.</p>
<p>See the help section about Bits# for advanced Bits# commands and how to<br />
establish communication and convenient control for the Bits# via USB<br />
connection.</p>
<p>cmd - The command that <a href="BitsPlusPlus" class="uri">BitsPlusPlus</a> should execute. cmd can be any of<br />
the following:</p>
<p>Load a linear identity mapping CLUT into Bits++ while running in Bits++<br />
mode:</p>
<p><a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘LoadIdentityClut’, window);</p>
<p>Will schedule update to an identity clut. Next invocation of<br />
<a href="Screen" class="uri">Screen</a>(‘<a href="Flip" class="uri">Flip</a>’, window); will actually upload the identity clut into<br />
Bits++.</p>
<p><a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘UseFE1StereoGoggles’, window, enable [, shutterState=0]);<br />
If ‘enable’ is 1, enable use of the CRS FE1 stereo goggles connected<br />
to the Bits display device. If ‘enable’ is 0 then disable use of the<br />
goggles again and put them in a resting state with either both shutters<br />
open (‘shutterState = 0’) or closed (‘shutterState = 1’).</p>
<h3 id="schedule-a-bits-dio-command-for-execution-on-next-screenflip">Schedule a Bits++ DIO command for execution on next <a href="Screen" class="uri">Screen</a>(‘<a href="Flip" class="uri">Flip</a>’):</h3>
<p><a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘DIOCommand’, window, repetitions, mask, data, command [, xpos, ypos]);</p>
<p>This will draw the proper T-Lock control codes at positions (xpos, ypos)<br />
for execution of the Bits++ DIO commands (mask, data, command).</p>
<p>You can specify multiple codes at once: If mask, data, command, xpos and<br />
ypos are matrices or vectors with ‘num’ rows, then each of the ‘num’ rows<br />
defines one T-Lock code. If mask, command, xpos and ypos are scalars and<br />
data is a one row vector, then only the corresponding T-Lock line is<br />
drawn.</p>
<p>For each DIO command:<br />
‘mask’ must be a 8 bit integer value, ‘command’ must be a 8 bit integer<br />
value, whereas ‘data’ must be a a 248 element row vector of bytes.</p>
<p>Consult your Bits++ manual for explanation of the meaning of the values.</p>
<p>xpos and ypos are optional: By default, the T-Lock code is drawn into the<br />
3rd pixel row of the output image, so it can’t collide with a potential<br />
T-Lock code for CLUT updates.</p>
<p>The DIO command will become effective during the next flip command. The<br />
T-Lock code is drawn during ‘repetitions’ successive invocations of<br />
<a href="Screen" class="uri">Screen</a>(‘<a href="Flip" class="uri">Flip</a>’). If you set ‘repetitions’ to -1, then the code will be<br />
drawn until you stop it via a call to <a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘DIOCommandReset’, window);</p>
<h3 id="disable-use-of-the-dio-t-lock-code-blitting">Disable use of the DIO T-Lock code blitting:</h3>
<p><a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘DIOCommandReset’, window);<br />
Stops blitting of T-Lock command codes immediately. If you want to use<br />
them again, you have to respecify codes via the <a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘DIOCommand’,…);</p>
<h3 id="manage-treatment-of-one-or-two-connected-crs-devices">Manage treatment of one or two connected CRS devices:</h3>
<p><a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘SetDualDevices’, mode);<br />
If ‘mode’ is set to 0, which is the default, assume one CRS device is connected.</p>
<p>If ‘mode’ is set to 1, then assume two CRS devices, e.g., 2 Display++ or<br />
Bits# devices are connected for dual-display stereo/binocular stimulation and<br />
adapt accordingly. Apply the same CLUT in Bits++ and Mono++ display mode<br />
to both connected display devices in stereomodes 4, 5 and 10.</p>
<p>Open a full-screen window on the Bits++ display as with<br />
<a href="Screen" class="uri">Screen</a>(‘OpenWindow’, …), perform all initialization:</p>
<p>The following commands will execute <a href="Screen" class="uri">Screen</a>(‘OpenWindow’) with all proper<br />
parameters, followed by Bits++ init routines. They are completely sufficient<br />
drop in replacements for <a href="Screen" class="uri">Screen</a>(‘OpenWindow’), accepting and returning<br />
exactly the same arguments that <a href="Screen" class="uri">Screen</a>() would do, adjusting all<br />
parameters to the constraints of the Bits++, if necessary.</p>
<h3 id="activate-bits-mode">Activate Bits++ mode:</h3>
<p>[win, winRect] = <a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘OpenWindowBits++’, screenid, …);</p>
<p>This will open an onscreen window on Bits++ screen ‘screenid’ with a<br />
standard 8 bits per color channel framebuffer. The gamma table of your<br />
graphics hardware will be loaded with an identity gamma table, so the<br />
T-Lock system of Bits++ works and Bits++ can accept commmands embedded<br />
into the stimulus images. Psychtoolbox will automatically embed a T-Lock<br />
control line into the top line of the display screen, which encodes the<br />
256 entry, 14 bit per color channel CLUT to use for Bits++ display mode.<br />
You can change the Bits++ CLUT at any time via the standard PTB<br />
<a href="Screen" class="uri">Screen</a>(‘LoadNormalizedGammaTable’, win, newclut, 2); command. The<br />
‘newclut’ will get uploaded to the Bits++ at the next invocation of<br />
<a href="Screen" class="uri">Screen</a>(‘<a href="Flip" class="uri">Flip</a>’) to allow updates of the CLUT synchronous to stimulus<br />
updates. ‘newclut’ has to be a 256 rows by 3 columns matrix with values<br />
in range 0.0 - 1.0: 0.0 is mapped to clut color value 0, 1.0 is mapped to<br />
the highest Bits++ output color value 16383.</p>
<p>This mode works on any <a href="OpenGL" class="uri">OpenGL</a> graphics hardware.</p>
<h3 id="activate-mono-mode">Activate Mono++ mode:</h3>
<p>[win, winRect] = <a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘OpenWindowMono++’, screenid, …);</p>
<p>This will open an onscreen window on Bits++ screen ‘screenid’ for display<br />
of pure luminance (grayscale) images. The framebuffer has a resolution of<br />
32 bit floating point precision by default: This means that pixel luminance<br />
values have to be specified as floating point numbers between 0.0 and<br />
1.0. 0.0 maps to black (Output intensity 0 on Bits++ device). 1.0 maps to<br />
white (Maximum output intensity 16383 on Bits++ device). The intensity<br />
range between 0.0 and 1.0 is internally represented and processed by<br />
Psychtoolbox with a resolution 23 bits, i.e. over 8 million levels of<br />
luminance. The Bits++ can resolve this range to 14 bits, ie. 16384 levels<br />
of luminance during display. This mode is not compatible with the use of<br />
any gamma- or clut- tables. Both the graphics hardwares gamma table and<br />
the Bits++ internal clut are set to an identity mapping while this mode<br />
is active. Please read the notes below the Color++ section for graphics<br />
hardware requirements and other useful tips for use of Bits++.</p>
<p>If you call this subfunction as ‘OpenWindowMono++WithOverlay’, the<br />
overlay plane of Bits++ gets enabled and an additional overlay window is<br />
created for drawing the image for that overlay plane.</p>
<p>[overlaywin, overlaywinRect] = <a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘GetOverlayWindow’, win);<br />
- Will return the handle to the ’overlaywin’dow associated with the<br />
onscreen luminance window:</p>
<p>‘overlayWin’ is the handle to the overlay window associated with the<br />
overlay of onscreen window ‘win’. The overlay window is a standard<br />
offscreen window, so you can do anything with it that you would want to<br />
do with offscreen windows. The only difference is that the window is a<br />
pure index window: It only has one “color channel”, which can be written<br />
with color values between 0 and 255. Values 1 to 255 get mapped to the<br />
corresponding color indices of the Bits++ overlay plane: A zero value is<br />
transparent – Content of the onscreen window is visible. Positive<br />
non-zero color values map to the 255 indices available in overlay mode,<br />
these get mapped by the Bits++ CLUT to colors. You can define the<br />
mapping of indices to CLUT colors via the<br />
<a href="Screen" class="uri">Screen</a>(‘LoadNormalizedGammaTable’, win, clut, 2); command.</p>
<p>Updates of the overlay image are synchronized to <a href="Screen" class="uri">Screen</a>(‘<a href="Flip" class="uri">Flip</a>’)<br />
updates. If you draw into the overlay window, the changed overlay image<br />
will become visible at <a href="Screen" class="uri">Screen</a>(‘<a href="Flip" class="uri">Flip</a>’) time – in sync with the changed<br />
onscreen window content. The overlay plane is not automatically cleared<br />
to background (or transparent) color after a flip, but its content<br />
persists across flips. You need to clear it out manually via a<br />
<a href="Screen" class="uri">Screen</a>(‘FillRect’) command.</p>
<h3 id="activate-color-mode">Activate Color++ mode:</h3>
<p>[win, winRect] = <a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘OpenWindowColor++’, screenid, …);</p>
<p>This will open an onscreen window on Bits++ screen ‘screenid’ for display<br />
of 14 bit per color component 42bpp color images. The framebuffer has<br />
a resolution of 32 bit floating point precision for each color component<br />
by default: This means that (Red, Green, Blue) color pixel component<br />
values have to be specified as floating point numbers between 0.0 and<br />
1.0. 0.0 maps to minimum output intensity on Bits++ device for a channel.<br />
1.0 maps to maximum output intensity 16383 on Bits++ device for a channel.<br />
The color intensity range between 0.0 and 1.0 is internally represented and<br />
processed by Psychtoolbox with an effective resolution of about 23 bits,<br />
i.e. over 8 million levels of color per color channel. The Bits++ can resolve<br />
this range to 14 bits, ie. 16384 levels of color during display. This mode<br />
is not compatible with the use of any gamma- or clut- tables. Both the graphics<br />
hardwares gamma table and the Bits++ internal clut are set to an identity<br />
mapping while this mode is active. Please read the notes below for graphics<br />
hardware requirements and other useful tips for use of Bits++.</p>
<p>If you use Color++ mode, you must call<br />
<a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘SetColorConversionMode’, mode); first to select the mode<br />
for sampling the framebuffer and converting into output color values. See<br />
the respective section of “help <a href="PsychImaging" class="uri">PsychImaging</a>” for ‘Color++’ or<br />
‘EnableDataPixxC48Output’ mode for the Bits+ or Datapixx device for an<br />
explanation of this mandatory parameter. The setting before 22nd<br />
September 2010 for all PTB-3 versions was 0 (==zero).</p>
<p>You can query the mode for an onscreen window ‘win’ by a call to:<br />
mode = <a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘GetColorConversionMode’, win);</p>
<h3 id="notes-for-both-mono-and-color-mode">Notes for both Mono++ and Color++ mode:</h3>
<p>In Mono++ and Color++ mode, PTB expects color values in the range 0.0 to<br />
1.0 instead of the (otherwise usual) range 0 to 255. The range 0.0-1.0<br />
is a more natural fit for high dynamic range/precision output devices than<br />
the 0-255 range with its strong ties to 8 bpc output devices. 0-1 is also<br />
the “natural” native color range of <a href="OpenGL" class="uri">OpenGL</a>, so colors in this range can<br />
be handled by the graphics hardware at a higher speed. You can change the<br />
mapping of input colors to output intensities by use of the command<br />
<a href="Screen" class="uri">Screen</a>(‘ColorRange’) (see its online help for usage), but in the interest<br />
of uniform code and to avoid possible side effects with some graphics<br />
hardware, we strongly recommend using the default 0.0-1.0 color range.</p>
<p>You can still pass standard 8bpc (256 color/intensity levels) color/luminance<br />
textures to PTB via standard use of <a href="Screen" class="uri">Screen</a>(‘MakeTexture’) - the hardware<br />
will convert such 8bpc images to OpenGL’s native color range, as well as<br />
any images delivered by the Quicktime movie playback engine or the video<br />
capture engine. If you want to provide high dynamic range, high color<br />
depths images, please specify them as Matlab double matrices to<br />
<a href="Screen" class="uri">Screen</a>(‘MakeTexture’) and set the optional flag ‘floatprecision’ to 1 or<br />
2, i.e., hdrtex = <a href="Screen" class="uri">Screen</a>(‘MakeTexture’, win, myHDRImage, [], [], 2);</p>
<p>Psychtoolbox will represent such images with an internal precision of 10<br />
bits + 1 bit sign if you choose the ‘floatprecision’ flag to be 1. If you<br />
choose a ‘floatprecision’ flag of 2, PTB will represent the images with<br />
an internal precision of 23 bits + 1 bit sign. You can provide negative<br />
color values as well, e.g., -0.5. If you wonder what the use of this<br />
might be, have a careful look at the tutorial script…<br />
‘AdditiveBlendingForLinearSuperpositionTutorial.m’<br />
… for an example of extremely fast drawing of luminance gratings with<br />
controllable size, orientation and contrast and correct linear superposition:</p>
<p>By default, PTB will use a 32-bit floating point framebuffer for your<br />
drawings, ie. the precision is way higher than needed for any high<br />
dynamic range/resolution display device in existence. The downside of this<br />
super-precision is that alpha-blending is not supported in this mode, unless<br />
you employ an <a href="NVidia" class="uri">NVidia</a> Geforce 8000 series (and later) graphics card, or a<br />
ATI Radeon HD2000/3000 series graphics card (and later). If you need<br />
alpha-blending on older/other hardware then specify the optional flag<br />
‘kPsychNeed16BPCFloat’ for the ‘imagingmode’ argument. This will reduce<br />
effective accuracy of the framebuffer to 10 bit precision, but allow for<br />
fast alpha-blending. 10 Bit precision are 4 bits less than the 14 bits<br />
that Bits++ can provide, but it will be possible to use the extra 14-10 =<br />
4 bits for gamma correction of the display by employing a gamma<br />
correction shader.</p>
<h3 id="gamma--and-color-correction">Gamma- and color correction:</h3>
<p>In Mono++ and Color++ mode, the hardware gamma tables of your graphics<br />
card and the Bits+ box can’t be used for gamma- or color correction.<br />
However, PTB provides a much more powerful and flexible color correction<br />
system for this purpose. See “help <a href="PsychColorCorrection" class="uri">PsychColorCorrection</a>” for further<br />
explanation and usage examples for standard gamma correction.</p>
<p>Graphics hardware requirements: Mono++ and Color++ mode require use of the<br />
Psychtoolbox imaging pipeline and floating point framebuffers. The<br />
minimum requirements are ATI Radeon X1000 series or <a href="NVidia" class="uri">NVidia</a> Geforce-6800<br />
series and later graphics hardware. We currently recommend <a href="NVidia" class="uri">NVidia</a><br />
Geforce-8000 series or ATI Radeon HD-2000/3000 hardware for best results.<br />
However, this functions have been successfully tested on ATI Radeon X1600<br />
and <a href="NVidia" class="uri">NVidia</a> Geforce-7800 hardware as well.</p>
<p>All Bits++ modes supported by this function should work Plug &amp; Play,<br />
requiring no changes to your stimulus code other than mentioned here to<br />
take full advantage of all functionality of Psychtoolbox just as with standard<br />
8 bpc displays at the higher 14 bpc quality of Bits++. If you find this<br />
not to be the case then it’s either an omission in our documentation<br />
or a bug - Please report it.</p>
<h3 id="bits-specific-functions">BITS# specific functions:</h3>
<p>A Bits# device which is connected via USB will show up as an additional<br />
serial port on the system. This driver will communicate with the Bits#<br />
by establishing a serial port connection to the device via that serial<br />
port. Presence of a Bits# can be signalled by either calling the <a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘OpenBits#’)<br />
function and passing a serial port device spec ‘portSpec’, or just by calling<br />
<a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘OpenBits#’) without any parameters. In the latter case, the<br />
driver will check for the existence of a configuration file named…<br />
[<a href="PsychtoolboxConfigDir" class="uri">PsychtoolboxConfigDir</a> ‘BitsSharpConfig.txt’]. Presence of the file means<br />
to use a Bits# device, absence means to treat any device as a Bits+ device.<br />
Presence of a serial port device file name in the first line of that text<br />
configuration file will use the serial port device with that name for<br />
communication, otherwise the driver will try to auto-detect the proper<br />
serial port for communication. If you have multiple such devices, you can add<br />
multiple lines with serial port names to the configuration file, and then select<br />
a given device by specifying a index into the file as ‘portSpec’. portSpec=1<br />
would use line 1 of the file for finding the device, portSpec=2 would use line 2<br />
etc.</p>
<p>[handle, portHandle] = <a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘OpenBits#’ [, portSpec]);<br />
– Open a serial port control connection to a connected Bits# device, return<br />
a non-zero ‘handle’ to it on success, or the value zero if no such device exists<br />
or could not be opened. On successfull open, a low-level ‘portHandle’ is returned<br />
as well, which allows access to the serial port control connection via <a href="IOPort" class="uri">IOPort</a> for<br />
people who really know what they are doing.</p>
<p>Note: The current implementation only allows to connect to one device at a time,<br />
therefore use of the returned ‘handle’ is not very useful at the moment.</p>
<p>The ‘portSpec’ parameter is optional and defines the name of the serial<br />
port(-device file) or index of the CRS device to use for the connection.<br />
If omitted, the name will be taken from a configuration file, or auto-detected.<br />
If specified as a string, the string defines the serial port device file. If<br />
specified as a numeric index, it selects the line within the configuration file<br />
from which the portname string will be taken, ie. index 1 = 1st line, 2 = 2nd line…</p>
<p>This function must be called before use of any Bits# specific functions, otherwise<br />
they’ll turn into no-ops or failures. This function can be called multiple times for<br />
a given device. It will only open the connection on first call. Successive calls will<br />
do nothing but increment a reference count of clients to the device.</p>
<p>rc = <a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘<a href="Close" class="uri">Close</a>’ [, handle]);<br />
– Decrement reference count to a Bits# device ‘handle’, close the serial<br />
connection to it once the count drops to zero, ie., as soon as nobody is using<br />
the connection anymore. If ‘handle’ is omitted, the ‘<a href="Close" class="uri">Close</a>’ call is executed for<br />
each currently open device.</p>
<p>rc = <a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘ResetOnWindowClose’);<br />
– Like ‘<a href="Close" class="uri">Close</a>’, but switch display back to Bits++ video mode first, as<br />
that mode is “GUI friendly”. Usually automatically called from <a href="Screen" class="uri">Screen</a>()<br />
when the Bits# stimulation onscreen window gets closed, at least if you<br />
used <a href="PsychImaging" class="uri">PsychImaging</a>() to control the device.</p>
<p>rc = <a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘CheckGPUSanity’, window, xoffset [, injectFault=0]);<br />
– Perform online-test of GPU identity gamma tables and DVI-D display<br />
encoders. Try to correct problems with wrong identity gamma tables and at<br />
least detect problems with (spatio-)temporal display dithering. Returns<br />
rc == 0 on full success, rc &gt; 0 on failure.<br />
If the optional ‘injectFault’ parameter is set to 1, then an intentionally<br />
perturbed gamma table is loaded into the gpu to test how well the gamma table<br />
tweaking code is able to recover from wrong tables.</p>
<p>pixels = <a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘GetVideoLine’, nrPixels, scanline);<br />
– Return the first (left-most) ‘nrPixels’ pixels in video scanline<br />
‘scanline’ of the video display driven by a Bits# device. ‘pixels’ is<br />
a uint8 matrix with three rows for red, green and blue pixel color values,<br />
and ‘nrPixels’ columns, the three elements of each column encoding the<br />
r,g,b color values of the pixel corresponding to that column (x-position)<br />
of the scanline (y-position). Values are read back via the USB-Serial<br />
connection from the Bits# and the device sends back the pixel data as<br />
received over the DVI-D link.</p>
<p><a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘SwitchToBits++’);<br />
– Switch Bits# to Bits++ mode.</p>
<p><a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘SwitchToMono++’);<br />
– Switch Bits# to Mono++ mode.</p>
<p><a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘SwitchToColor++’);<br />
– Switch Bits# to Color++ mode.</p>
<p><a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘SwitchToStatusScreen’);<br />
– Switch Bits# to Status screen display.</p>
<p><a href="BitsPlusPlus" class="uri">BitsPlusPlus</a>(‘MassStorageMode’);<br />
– Switch Bits# to <a href="MassStorageMode" class="uri">MassStorageMode</a>. This will forcefully close allow<br />
client connections to the device, close the USB serial port connection<br />
and close the driver. The Bits# will report into USB mass storage mode,<br />
where it can get accessed like a USB flash drive, e.g., to edit configuration<br />
files, update firmware or EDID’s etc. Only a power-cycle will bring the<br />
device back into a mode which allows us to connect to it again.</p>
<div class="code_header" style="text-align:right;">
<p><span style="float:left;">Path  </span> <span class="counter">Retrieve <a href=
  "https://raw.github.com/Psychtoolbox-3/Psychtoolbox-3/beta/Psychtoolbox/PsychGLImageProcessing/BitsPlusPlus.m">current version from GitHub</a> | View <a href=
  "https://github.com/Psychtoolbox-3/Psychtoolbox-3/commits/beta/Psychtoolbox/PsychGLImageProcessing/BitsPlusPlus.m">changelog</a></span></p>
</div>
<div class="code">
<p><code>Psychtoolbox/PsychGLImageProcessing/BitsPlusPlus.m</code></p>
</div>
