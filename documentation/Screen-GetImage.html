<h1 id="screengetimage"><a href="Screen-GetImage">Screen(‘GetImage’)</a></h1>
<h2 id="psychtoolbox-screen.mexdll-subfunction">[[Psychtoolbox]] › [[Screen]].{mex*,dll} subfunction</h2>
<p>Slowly copy an image from a window or texture to Matlab/Octave, by default<br />
returning a uint8 array.</p>
<p>Calling this function on an onscreen window while an asynchronous flip is<br />
pending on the window due to <a href="Screen" class="uri">Screen</a>(‘AsyncFlipBegin’) is not allowed. Finalize<br />
such flips first. Readback of other onscreen or offscreen windows or textures is<br />
possible during async flip, but discouraged because it will have a significant<br />
impact on performance.</p>
<p>The returned imageArray by default has three layers, i.e. it is an RGB image.</p>
<p>“windowPtr” is the handle of the onscreen window, offscreen window or texture<br />
whose image should be returned.</p>
<p>“rect” is the rectangular subregion to copy, and its default is the whole<br />
window. The specified image subregion must be fully contained inside the window,<br />
otherwise this function will abort with an error.</p>
<p>Matlab/Octave will complain if you try to do math on a uint8 array, so you may<br />
need to use DOUBLE to convert it, e.g. imageArray/255 will produce an error, but<br />
double(imageArray)/255 is ok. Also see <a href="Screen" class="uri">Screen</a> ‘PutImage’ and ‘CopyWindow’.</p>
<p>“bufferName” is a string specifying the buffer from which to copy the image: The<br />
‘bufferName’ argument is meaningless for offscreen windows and textures and will<br />
be silently ignored. For onscreen windows, it defaults to ‘frontBuffer’, i.e.,<br />
it returns the image that is sent through the video output of your graphics card<br />
to your display device at that moment. On <a href="OpenGL" class="uri">OpenGL</a>-ES graphics hardware, all<br />
‘bufferName’ settings except ‘backBuffer’ or ‘drawBuffer’ will be ignored and<br />
image data is always read from either the ‘drawBuffer’ or the ‘backBuffer’. This<br />
is an unavoidable system limitation of such embedded hardware.<br />
If frame-sequential stereo mode is enabled, ‘frontLeftBuffer’ returns the image<br />
generated for the left eye, ‘frontRightBuffer’ returns the right-eye view. If<br />
double-buffering is enabled, you can also return the ‘backBuffer’, i.e. what<br />
your subject will see after the next <a href="Screen" class="uri">Screen</a>(‘<a href="Flip" class="uri">Flip</a>’) command, and for<br />
frame-sequential stereo also ‘backLeftBuffer’ and ‘backRightBuffer’<br />
respectively. Both the ‘frontBuffer’ and ‘backBuffer’ images and their stereo<br />
variants will return the final images as they are really encoded in the system<br />
framebuffer and sent to the video outputs of your graphics hardware. These<br />
images are the result of any post-processing done by the Psychtoolbox imaging<br />
pipeline, e.g., Retina display processing, geometric transformations, color<br />
transformations, certain types of gamma correction, stereo post-processing, or<br />
special pixel encoding for devices like Bits# or Datapixx. As such they may<br />
differ in size and format from what you have drawn into the onscreen window.<br />
‘aux0Buffer’ - ‘aux3Buffer’ returns the content of <a href="OpenGL" class="uri">OpenGL</a> AUX buffers 0 to 3.<br />
Only query the AUX buffers if you know what you are doing, otherwise your script<br />
will crash. This is mostly meant for internal debugging of PTB.<br />
If the imaging pipeline is enabled, you can also return the content of the<br />
unprocessed backbuffer, ie. before processing by the pipeline, by requesting<br />
‘drawBuffer’.<br />
If the imaging pipeline is enabled, querying the ‘backBuffer’ will only give you<br />
up to date results after you called <a href="Screen" class="uri">Screen</a>(‘<a href="Flip" class="uri">Flip</a>’) or <a href="Screen" class="uri">Screen</a>(‘AsyncFlipBegin’)<br />
or <a href="Screen" class="uri">Screen</a>(‘DrawingFinished’), otherwise you may encounter stale results. If our<br />
own homegrown frame-sequential stereo mode is in use, querying the<br />
‘backLeftBuffer’ and ‘backRightBuffer’ is well defined, after a <a href="Screen" class="uri">Screen</a>(‘<a href="Flip" class="uri">Flip</a>’)<br />
or <a href="Screen" class="uri">Screen</a>(‘DrawingFinished’), but querying the ‘frontLeftBuffer’ or<br />
‘frontRightBuffer’ or ‘frontBuffer’ will result in an assignment of left- and<br />
right- stereo images that is mostly based on chance, e.g., you may get<br />
accidentally swapped left- and rightBuffer images!</p>
<p>“floatprecision” If you set this optional flag to 1, the image data will be<br />
returned as a double precision matrix instead of a uint8 matrix. Please note<br />
that normal image data will be returned in the normalized range 0.0 to 1.0<br />
instead of 0 - 255. Floating point readback is only beneficial when reading back<br />
floating point precision textures, offscreen windows or the framebuffer when the<br />
imaging pipeline is active and HDR mode is selected (ie. more than 8bpc<br />
framebuffer). On <a href="OpenGL" class="uri">OpenGL</a>-ES hardware, only floating point framebuffers do support<br />
‘floatprecision’ readback.<br />
“nrchannels” Number of color channels to return. By default, 3 channels (RGB)<br />
are returned. Specify 1 for Red/Luminance only, 2 for Red+Green or<br />
Luminance+Alpha, 3 for RGB and 4 for RGBA. A setting of 2 is not supported on<br />
<a href="OpenGL" class="uri">OpenGL</a>-ES hardware.</p>
<p>&lt;&lt;=====See also:===== PutImage CopyWindow CreateMovie FinalizeMovie &lt;&lt;</p>
