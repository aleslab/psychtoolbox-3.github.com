<h1 id="psychportaudiofillbuffer"><a href="PsychPortAudio-FillBuffer">PsychPortAudio(‘FillBuffer’)</a></h1>
<h2 id="psychtoolbox-psychportaudio.mexdll-subfunction">[[Psychtoolbox]] › [[PsychPortAudio]].{mex*,dll} subfunction</h2>
<p>Fill audio data playback buffer of a <a href="PortAudio" class="uri">PortAudio</a> audio device. ‘pahandle’ is the<br />
handle of the device whose buffer is to be filled. ‘bufferdata’ is usually a<br />
matrix with audio data in double() or single() format. Each row of the matrix<br />
specifies one sound channel, each column one sample for each channel. Only<br />
floating point values are supported. Samples need to be in range -1.0 to +1.0,<br />
with 0.0 for silence. This is intentionally a very restricted interface. For<br />
lowest latency and best timing we want you to provide audio data exactly at the<br />
optimal format and sample rate, so the driver can safe computation time and<br />
latency for expensive sample rate conversion, sample format conversion, and<br />
bounds checking/clipping.<br />
Instead of a matrix, you can also pass in the bufferhandle of an audio buffer as<br />
‘bufferdata’. This buffer must have been created beforehand via<br />
<a href="PsychPortAudio" class="uri">PsychPortAudio</a>(‘CreateBuffer’, …). Its content must satisfy the same<br />
constraints as in case of passing a Matlab matrix. The content will be copied<br />
from the given buffer to the standard audio buffer, so it is safe to delete that<br />
source buffer if you want.<br />
‘streamingrefill’ optional: If set to 1, ask the driver to refill the buffer<br />
immediately while playback is active. You can think of this as appending the<br />
audio data to the audio data already present in the buffer. This is useful for<br />
streaming playback or for creating live audio feedback loops. However, the<br />
current implementation doesn’t really append the audio data. Instead it replaces<br />
already played audio data with your new data. This means that if you try to<br />
refill more than what has been actually played, this function will wait until<br />
enough storage space is available. A ‘streamingrefill’ flag of 2 will always<br />
refill immediately, ie., without waiting for sufficient buffer space to become<br />
available, even if this causes audible artifacts or some sound data to be<br />
overwritten. This is useful for a few very special audio feedback tricks, only<br />
use if you really know what you’re doing!<br />
It will also fail if you try to refill more than the total buffer capacity.<br />
Default is to not do streaming refills, i.e., the buffer is filled in one batch<br />
while playback is stopped. Such a refill will also reset any playloop setting<br />
done via the ‘SetLoop’ subfunction to the full size of the refilled buffer.<br />
If the ‘streamingrefill’ flag is non-zero and the optional ‘startIndex’ argument<br />
is provided, then the refilling of the buffer will happen at the provided linear<br />
sample index ‘startIndex’. If the argument is omitted, new data will be appended<br />
at the end of the current soundbuffers content. The ‘startIndex’ argument is<br />
ignored if no streaming refill is requested.</p>
<p>Optionally the function returns the following values:<br />
‘underflow’ A flag: If 1 then the audio buffer underflowed because you didn’t<br />
refill it in time, ie., some audible glitches were present in playback and your<br />
further playback timing is screwed.<br />
‘nextSampleStartIndex’ This is the absolute index in samples since start of<br />
playback of the sample that would follow after the last sample you added during<br />
this ‘FillBuffer’ call, ie., the first sample during a successive ‘FillBuffer’<br />
call.<br />
‘nextSampleETASecs’ This value is undefined <a href="(NaN)" class="uri">(NaN)</a> if playback isn’t running.<br />
During a streaming refill, it contains the predicted audio onset time in seconds<br />
of the sample with index ‘nextSampleStartIndex’. Please note that this<br />
prediction can accumulate a prediction error if your buffer is so large that it<br />
contains samples that will only playback far in the future.</p>
<p>&lt;&lt;=====See also:===== Open GetDeviceSettings &lt;&lt;</p>
