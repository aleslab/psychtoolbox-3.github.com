<h2 id="psychtoolbox-psychopengl">[[Psychtoolbox]] › [[PsychOpenGL]]</h2>
<p>Matlab <a href="OpenGL" class="uri">OpenGL</a> Morpher - Performs linear morphs between different 3D shapes and<br />
renders the resulting shape via <a href="OpenGL" class="uri">OpenGL</a>. Supports high-performance GPU<br />
based morphing on recent graphics hardware. Also performs linear morphing<br />
(linear combinations) between different texture images.</p>
<p>The <a href="moglmorpher" class="uri">moglmorpher</a> computes linear combinations of shapes and their corresponding<br />
surface normal vectors and texture coordinate assignments. It then renders the<br />
resulting shape with its resulting surface normals and texture coordinates in<br />
an efficient way, using the <a href="OpenGL" class="uri">OpenGL</a> for Matlab (MOGL) functions.</p>
<p>It also allows to render single sub-meshes efficiently, as well as<br />
predictions of screen space 2D (x,y) coordinates of vertices in the mesh.</p>
<p>The whole setup for rendering (rigid orientation and position, camera view transforms,<br />
assignment and setup of textures or material properties, lighting, shaders, …) is<br />
left to the calling parent routines, focusing solely on high performance morphing<br />
and rendering of generic triangle meshes. This allows for maximum flexibility.</p>
<p>For a specific examples of usage, have a look at <a href="MorphDemo" class="uri">MorphDemo</a>.m and<br />
<a href="MorphTextureDemo" class="uri">MorphTextureDemo</a>.m.</p>
<p>IMPORTANT: At the end of your script, you must call <a href="moglmorpher" class="uri">moglmorpher</a>(‘reset’)<br />
to release all ressources and reset <a href="moglmorpher" class="uri">moglmorpher</a> into a well-defined<br />
state. Alternatively, you can call ‘clear <a href="moglmorpher" class="uri">moglmorpher</a>’, e.g., if your<br />
script aborted with an error. If your forget either of these, you’ll see<br />
some weird error messages about “Invalid window record referenced”<br />
at invocation of the command.</p>
<h1 id="available-subcommands-and-their-meaning">Available subcommands and their meaning</h1>
<p><a href="moglmorpher" class="uri">moglmorpher</a>(‘ForceGPUMorphingEnabled’, enableflag);</p>
<p>Forcefully enable or disable GPU based morphing. ‘enableFlag’==1 -&gt;<br />
Forcefully enable, ‘enableFlag’==0 –&gt; Forcefully disable.</p>
<p><a href="moglmorpher" class="uri">moglmorpher</a> can perform all morphing computations and rendering completely<br />
on the GPU on modern graphics hardware that supports this. This provides<br />
a significant speedup over morphing in Matlab/Octave code on the slower<br />
CPU. Normally, <a href="moglmorpher" class="uri">moglmorpher</a> auto-detects if GPU based morphing is possible<br />
and then enables that feature. If GPU morphing is not possible, it<br />
reverts to a slower Matlab CPU implementation of morphing. For GPU<br />
morphing, the Psychtoolbox imaging pipeline needs to be enabled by<br />
passing an optional valid non-zero ‘imagingMode’ flag to the<br />
<a href="Screen" class="uri">Screen</a>(‘OpenWindow’, …); call when opening the onscreen window. E.g.,<br />
the flag ‘kPsychNeedFastOffscreenWindows’ would enable the pipeline.</p>
<p>There may be cases where either auto-detection goes wrong, or where you<br />
don’t want to use GPU based morphing, e.g., if your hardware/gfx-driver<br />
is defective and GPU morphing doesn’t work correctly, or if you want to<br />
use the <a href="moglmorpher" class="uri">moglmorpher</a>(‘renderNormals’) subfunction which is not yet<br />
supported in GPU mode, or if you want to perform benchmarking of GPU<br />
vs. non-GPU mode. In such cases you can use this subfunction to manually<br />
enable/disable GPU based morphing, overriding the auto-detection code.</p>
<p>It’s important to call this function before the first invocation of any<br />
other subfunction!</p>
<p>GPU based operation should be efficiently supported on all ATI Radeon<br />
X-1000 or later hardware and all <a href="NVidia" class="uri">NVidia</a> Geforce-6000 and later hardware.<br />
GPU based operation is not supported under <a href="OpenGL" class="uri">OpenGL</a>-ES1.x mobile/embedded<br />
<a href="GPUs" class="uri">GPUs</a>.</p>
<p>All following subfunctions must be only called when at least one onscreen<br />
window is open!</p>
<p>meshid = <a href="moglmorpher" class="uri">moglmorpher</a>(‘addMesh’, obj);<br />
– Add a new shape to the collection of shapes to be morphed. ‘obj’<br />
is a single struct that defines the object: Subfields are obj.faces,<br />
obj.vertices, obj.texcoords, obj.normals, obj.colors. Their meaning is<br />
the same as the corresponding parameters in the following ‘addMesh’<br />
subcommand. The ‘obj’ syntax is provided for convenience, as ‘obj’ in the<br />
same format as provided by <a href="LoadOBJFile" class="uri">LoadOBJFile</a>, i.e. obj =<br />
<a href="LoadOBJFile" class="uri">LoadOBJFile</a>(‘myfile.obj’) will load the geometry in ‘myfile.obj’ into<br />
obj, which can then be passed to <a href="moglmorpher" class="uri">moglmorpher</a> via <a href="moglmorpher" class="uri">moglmorpher</a>(‘addMesh’,<br />
obj{1}); to add the first mesh from ‘myfile.obj’ into the morpher.</p>
<p>meshid = <a href="moglmorpher" class="uri">moglmorpher</a>(‘addMesh’, faces, vertices [, texcoords] [, normals] [, colors]);<br />
– Add a new shape to the collection of shapes to be morphed. faces == Index<br />
list that defines the topology of the shape: faces is a 3 by n vector. Each of<br />
the n columns defines one 3D triangle face, the 3 indices in the column are<br />
indices into the vertices, texcoords, colors and normals vectors that define the<br />
properties of the vertices.</p>
<p>vertices == A 3-by-m vector that defines the shape of the object: Each of the<br />
m columns defines the 3D position of one of the corresponding m vertices.</p>
<p>normals == A 3-by-m vector whose single columns define the (nx,ny,nz) components<br />
of unit normal surface vectors. The normals vector is optional and only needed if<br />
you want to do proper lighting calculations on your object.</p>
<p>texcoords == A 2-by-m vector of 2D texture coordinates for each corresponding vertex.<br />
This vector is optional and only needed if you want to apply textures to the object.</p>
<p>colors == A 3-by-m or 4-by-m vector whose single columns define the<br />
(red,green,blue [,alpha]) vertex color components of each vertex in<br />
‘vertices’ of unit normal surface vectors. The colors vector is optional<br />
and only needed if you want to do lighting calculations on your object.<br />
Most of the time you won’t use vertex colors, but instead assign a<br />
texture for more flexibility and ease of use.<br />
Note: The current implementation doesn’t support morphing of vertex<br />
colors. Instead it will simply use the vertex ‘color’ vector of the last<br />
added mesh for the morphed output – a fixed assignment of vertex colors.</p>
<p>The size and dimension of all provided vectors must match (==be identical) for all<br />
shapes. This is required, because otherwise the linear combination of shapes and<br />
normal vectors wouldn’t be mathematically well defined.</p>
<p>The function call returns a index for the mesh. The index is fixed for a<br />
given mesh unless you call <a href="moglmorpher" class="uri">moglmorpher</a>(‘deleteMeshAtIndex’), in which<br />
case the numbering may change. See ‘deleteMeshAtIndex’ for details.</p>
<p><a href="moglmorpher" class="uri">moglmorpher</a>(‘deleteMeshAtIndex’, meshIndex [, dontReset=0]);<br />
– Delete the mesh with index ‘meshIndex’ from the set of keyshapes. All<br />
keyshapes after the deleted meshIndex will “move down” one index. E.g.,<br />
if you delete the keyshape at meshIndex = 5, then the mesh with previous<br />
index 6 will become the new mesh with index 5, the mesh with old index 7 will<br />
become mesh 6 and so on. You have to take this renumbering into account<br />
for calls like <a href="moglmorpher" class="uri">moglmorpher</a>(‘renderMesh’) that expect the meshid, and when<br />
passing in a morph ‘weights’ vector into the morphing functions, where<br />
the ordering of elements changes accordingly.</p>
<p>‘dontReset’ optional: If set to 1 then <a href="moglmorpher" class="uri">moglmorpher</a> doesn’t ‘reset’ itself<br />
when the last mesh is deleted. This saves overhead for reinit, but any<br />
new added mesh must have the exactly same topology as the previously<br />
deleted meshes, or bad things will happen.</p>
<p><a href="moglmorpher" class="uri">moglmorpher</a>(‘renderMesh’, meshid);<br />
– Render the mesh corresponding to the handle ‘meshid’.</p>
<p>oldEnable = <a href="moglmorpher" class="uri">moglmorpher</a>(‘assumeSparseMorphWeights’, enable);<br />
– Enable speed optimizations under the assumption that morph weight<br />
vector contains mostly zero weights, if ‘enable’ is set to 1. Otherwise<br />
optimize speed under the assumption of dense weight vectors. The default<br />
is to assume dense vectors, ie., ‘enable’ == 0.</p>
<p>Two different algorithms are used, depending on the setting of this<br />
switch, which have different tradeoffs. However, switching settings here<br />
is cheap, so you could do it on a per-morph basis. The optimal choice may<br />
depend on complexity of your keyshape models and speed of your GPU, so<br />
your mileage will vary and you’ll need to benchmark both options for<br />
optimal speed.</p>
<p><a href="moglmorpher" class="uri">moglmorpher</a>(‘renderMorph’, weights [,morphnormals=1]);<br />
– Compute a linear combination (a weighted average) of all stored meshes, as defined<br />
by the vector ‘weights’. Render the final shape.<br />
For ‘count’ shapes, weight is a vector of length ‘count’. The i’th scalar entry of weight<br />
is the coefficient used to integrate the i’th shape into the morph.</p>
<p><a href="moglmorpher" class="uri">moglmorpher</a>(‘computeMorph’, weights [,morphnormals=1]);<br />
– Same as ‘renderMorph’, just that rendering of the morphed shape is<br />
omitted. You can render the shape later by calling the ‘render’ subcommand.</p>
<p>finalresult = sum_for_i=1_to_count(shape(i) * weights(i));<br />
The shape (vertices) and normal vectors are linearly combined. The texture coordinates are<br />
not altered by the morph, neither are the vertex colors. If you set the<br />
optional argument morphnormals to zero, then normals are not touched by<br />
morphing either.</p>
<p><a href="moglmorpher" class="uri">moglmorpher</a>(‘render’);<br />
– Renders the last shape again. This is either the last rendered mesh or the last linear<br />
combination.</p>
<p>glListHandle = <a href="moglmorpher" class="uri">moglmorpher</a>(‘renderToDisplaylist’);<br />
– Same as subcommand ‘render’, but the shape is not rendered as an image to the<br />
framebuffer, but stored to a new <a href="OpenGL" class="uri">OpenGL</a> display list. A unique ‘glListHandle’ to<br />
the new list is returned. Using this handle one can render the object<br />
later on via the command glCallList(glListHandle); and delete it via<br />
glDeleteLists(glListHandle, 1);</p>
<p>Unsupported on <a href="OpenGL" class="uri">OpenGL</a>-ES.</p>
<p><a href="moglmorpher" class="uri">moglmorpher</a>(‘renderRange’ [, startfaceidx=0] [, endfaceidx]);<br />
<a href="moglmorpher" class="uri">moglmorpher</a>(‘renderRangeToDisplayList’ [, startfaceidx=0] [, endfaceidx]);<br />
– Like ‘render’ and ‘renderToDisplayList’, except that the range of<br />
faces (triangles or quads) can be restricted to a subrange of the mesh.<br />
By default, the full mesh is rendered. ‘startfaceidx’ Allows start at<br />
given index instead of index zero. ‘endfaceidx’ Allows end at<br />
given index instead of the last face index in the mesh.</p>
<p>Caution: Face indices count in units of surface primitives. 1 count = 1<br />
triangle or quad, depending on the type of your mesh.</p>
<p>Caution: Face indices are zero-based! The first element is at index zero.<br />
This is different from the one-based indexing of vertices in the<br />
functions ‘renderNormals’ and ‘getVertexPositions’, where index 1 denotes<br />
the first vertex in the mesh.</p>
<p><a href="moglmorpher" class="uri">moglmorpher</a>(‘renderNormals’ [,normalLength=1] [, startidx=1] [, endidx]);<br />
– Renders the surface normal vectors of the last shape in green, either at unit-length,<br />
or at ‘normalLength’ if this argument is provided. This is a helper function for<br />
checking the correctness of computed normals. It is very slow!</p>
<p>vpos = <a href="moglmorpher" class="uri">moglmorpher</a>(‘getVertexPositions’, windowPtr [, startidx=1] [, endidx]);<br />
– Compute and return a matrix which contains the projected screen space coordinates of all<br />
vertices that would be rendered when calling <a href="moglmorpher" class="uri">moglmorpher</a>(‘render’). windowPtr is the handle<br />
of the window into which we render. Optional arguments startidx and endidx define the<br />
index of the first vertex, resp. the last vertex to transform. The returned ‘vpos’ is a<br />
vcount-by-3 matrix, where vcount is the number of returned vertices, and row i contains the<br />
projected 3D position of the i’th vertex vcount(i,:) = (screen_x, screen_y, depth_z);<br />
Unsupported on <a href="OpenGL" class="uri">OpenGL</a>-ES.</p>
<p>count = <a href="moglmorpher" class="uri">moglmorpher</a>(‘getMeshCount’);<br />
– Returns number of stored shapes.</p>
<p>textureCoordinates = <a href="moglmorpher" class="uri">moglmorpher</a>(‘getTexCoords’);<br />
– Returns current vector of textureCoordinates as used for rendering<br />
meshes.</p>
<p>[vertices, normals] = <a href="moglmorpher" class="uri">moglmorpher</a>(‘getGeometry’);<br />
– Returns current vector of ‘vertices’ and (optionally) normals as used<br />
for rendering meshes. Call this after (at least one call to)<br />
‘computeMorph’ or ‘renderMorph’ to retrieve the current morphed mesh.<br />
vertices and normals are 3-by-n matrices, each column encoding the three<br />
components (x,y,z) of a single 3D vertex position or vertex normal.</p>
<p>[texid, gltexid, gltextarget] = <a href="moglmorpher" class="uri">moglmorpher</a>(‘morphTexture’, windowPtr, morphWeights, keyTextures);<br />
– Compute a linear combination of the Psychtoolbox textures stored in<br />
vector ‘keyTextures’, using the values in vector ‘morphWeights’ as<br />
weights. Return handles to the computed (morphed) texture. ‘texid’ is a<br />
Psychtoolbox texture handle (e.g., for use with <a href="Screen" class="uri">Screen</a>(‘DrawTexture’)),<br />
gltexid is an <a href="OpenGL" class="uri">OpenGL</a> texture handle and gltextarget is an <a href="OpenGL" class="uri">OpenGL</a> texture<br />
target. The texture could be used for rendering, e.g., onto a surface via<br />
glBindTexture(gltextarget, gltexid); and disabled again via<br />
glBindTexture(gltextarget, 0);</p>
<p>Input textures must be rectangle textures and the output texture will be<br />
a rectangle texture. The morphed texture ‘texid’ is owned by <a href="moglmorpher" class="uri">moglmorpher</a>.<br />
You must not close it or bad things will happen!</p>
<p><a href="moglmorpher" class="uri">moglmorpher</a>(‘reset’);<br />
– Resets the <a href="moglmorpher" class="uri">moglmorpher</a> - deletes all internal data structures.</p>
<h3 id="context-management-functions">CONTEXT MANAGEMENT FUNCTIONS:</h3>
<p><a href="moglmorpher" class="uri">moglmorpher</a>() supports use of more than one morph context. This is useful<br />
if you have to morph multiple separate morph-models. You can create<br />
and setup one dedicated context for each such model. Then you can switch<br />
between contexts before executing <a href="moglmorpher" class="uri">moglmorpher</a>() commands. The commands<br />
will always apply to the current set context. Once you’re done, you can<br />
delete contexts.</p>
<p>Context switching is not free! It comes at a modest cost in terms of<br />
computation time spent if you have GPU based morphing enabled. It can<br />
consume significant time if you use software only morphing with models of<br />
non-trivial size.</p>
<p>Use of these functions is optional. If you don’t use them to create your<br />
own contexts, <a href="moglmorpher" class="uri">moglmorpher</a> will create a single default context and use<br />
that. This ensures backwards compatibility to old scripts and<br />
single-context scripts.</p>
<h3 id="the-following-functions-allow-context-management">The following functions allow context management:</h3>
<p>context = <a href="moglmorpher" class="uri">moglmorpher</a>(‘createContext’ [, windowPtr]);<br />
– Create a new morphing context, attached to onscreen window ‘windowPtr’<br />
- or the default window if ‘windowPtr’ is omitted. Return it in<br />
‘context’. If you want to setup and then use the ‘context’, you will need<br />
to call ‘setContext’.</p>
<p>oldcontext = <a href="moglmorpher" class="uri">moglmorpher</a>(‘setContext’, context);<br />
– Set ‘context’ as the new morph context, return the previously set<br />
current context optionally in ‘oldcontext’. All other <a href="moglmorpher" class="uri">moglmorpher</a>()<br />
commands always operate on the current morph context until you change the<br />
morphcontext to a new current morph context with this ‘setContext’<br />
command. If you don’t use ‘setContext’ in your scripts, <a href="moglmorpher" class="uri">moglmorpher</a> will<br />
automatically create and bind a default context for use. This ensures<br />
backwards compatibility to scripts which don’t need multiple morph<br />
contexts.</p>
<p>currentContext = <a href="moglmorpher" class="uri">moglmorpher</a>(‘getContext’);<br />
– Return the currently set morph context. If ‘createContext’ and<br />
‘setContext’ weren’t used, this is the default context which was<br />
automatically created by <a href="moglmorpher" class="uri">moglmorpher</a>.</p>
<p>context = <a href="moglmorpher" class="uri">moglmorpher</a>(‘deleteContext’, context);<br />
– Delete given ‘context’ and release all its associated resources,<br />
return an emptied out copy in the optional return argument ‘context’.</p>
<p>IMPORTANT: You *must* delete all contexts with this method which have<br />
been created by ‘createContext’, otherwise you will leak resources!<br />
The exception is the currently bound context, which will get deleted<br />
automatically if <a href="moglmorpher" class="uri">moglmorpher</a>(‘reset’); is called, but not otherwise!</p>
<p>If in doubt, call this on each of your contexts and then some…</p>
<p>One convenient way to release all resources and clean out all contexts is<br />
to call “clear all”, this will reset everything. However, do not use<br />
“clear all” inside scripts which are supposed to work within GNU/Octave!<br />
Only call at the command prompt.</p>
<div class="code_header" style="text-align:right;">
<p><span style="float:left;">Path  </span> <span class="counter">Retrieve <a href=
  "https://raw.github.com/Psychtoolbox-3/Psychtoolbox-3/beta/Psychtoolbox/PsychOpenGL/moglmorpher.m">current version from GitHub</a> | View <a href=
  "https://github.com/Psychtoolbox-3/Psychtoolbox-3/commits/beta/Psychtoolbox/PsychOpenGL/moglmorpher.m">changelog</a></span></p>
</div>
<div class="code">
<p><code>Psychtoolbox/PsychOpenGL/moglmorpher.m</code></p>
</div>
