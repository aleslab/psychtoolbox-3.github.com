<h2 id="psychtoolbox-psychhardware">[[Psychtoolbox]] › [[PsychHardware]]</h2>
<p><a href="CMUBox" class="uri">CMUBox</a> - Access CMU response button box or PST serial response button box as well as fORP and Bitwhacker devices.</p>
<p>This allows to query button response boxes of type CMU (Carnegie Mellon<br />
University box) and PST (E-Prime response box). It also allows to use a<br />
UBW32/Bitwhacker device to be used as a response box if the device is<br />
loaded with the <a href="StickOS" class="uri">StickOS</a> firmware from http://cpustick.com. It also allows<br />
to use the Curdes fORP devices if connected via serial port. And it offers<br />
a simple way to access the <a href="RTBox" class="uri">RTBox</a> in E-Prime mode.</p>
<p>Note to MS-Windows users: You may need to setup the COM port of your machine<br />
properly and then reboot once to get correct timing. In the device manager<br />
for the COM ports, there is some “Advanced settings” tab or button somewhere.<br />
If you find a section called “FIFO size” or similar, set the FIFO size to<br />
a setting of 1 Byte, or disable FIFO’s completely. Otherwise you may get<br />
inaccurate timestamps or many timestamp warnings from <a href="CMUBox" class="uri">CMUBox</a>(‘GetEvent’).<br />
As far as USB-serial converters go, only converters from FTDI have been tested<br />
to be well behaved.</p>
<h1 id="commands-and-their-syntax">Commands and their syntax</h1>
<p>handle = <a href="CMUBox" class="uri">CMUBox</a>(‘Open’, boxtype [, portName] [, options] [, debounceSecs=0.030] [, isInverted]);<br />
- Open response box connected to serial port ‘portName’, or the first<br />
serial port found, if ‘portName’ is omitted. Initialize it, return a<br />
‘handle’ to it. You’ll have to pass ‘handle’ to all following functions<br />
to access the box.</p>
<p>If your system has multiple devices connected to multiple serial ports<br />
then you should explicitely specify the ‘portName’, otherwise the driver<br />
may connect to the wrong port and choke!</p>
<p>The optional string parameter ‘options’ allows to tweak the behaviour of<br />
the driver for certain configurations. It supports the following options:</p>
<p>‘ftdi’ - Tells the driver that it is connecting to a Serial-over-USB port<br />
and that the converter/driver is from FTDI Inc., or a compatible device.<br />
Allows for certain optimizations in timing accuracy.</p>
<p>‘norelease’ - Tells the driver it shouldn’t report button release / TTL<br />
transition to low events, but only button presses and TTL onsets.</p>
<p>The optional parameter ‘debounceSecs’ sets the debounce interval for<br />
button debouncing if the Bitwhacker is used as response box. After a<br />
button press, the device will wait for all the buttons to be released for<br />
at least ‘debounceSecs’ seconds. Only then will it accept new button<br />
presses. The default setting is 30 msecs if this option is omitted.</p>
<p>The optional parameter vector ‘isInverted’ defines whether a TTL input<br />
signal level of logic low (0) corresponds to a button press or a button<br />
release. By default, a level of logic low is detected as button press.The<br />
vector has nine elements, one for each corresponding input line. If an<br />
element is 1, then a logic level of low is registered as a button press.<br />
A value of 0 means that a logic level of high is registered as a button<br />
press. E.g., isInverted = [ 0 0 0 0 1 1 1 1 1 ] would register a logic<br />
level of low as a button press on the first four inputs, whereas a level<br />
of high is required to detect a button press on the last five inputs.</p>
<p>The mandatory parameter ‘boxtype’ is a name string defining the<br />
type/model of box to connnect to. Supported settings are:</p>
<p>‘bitwhacker’ - Connect to UBW32/Bitwhacker with <a href="StickOS" class="uri">StickOS</a> Firmware,<br />
reconfigure it to impersonate a response box.</p>
<p>‘cmu’ - Connect to CMU serial port response button box, assuming 19.2<br />
<a href="KBaud" class="uri">KBaud</a> datarate, 8 databits, 1 stop bit, odd parity.</p>
<p>‘pst’ - Connect to PST serial port response button box in E-Prime<br />
configuration with 800 streaming samples per second at 19200 Baud, 8<br />
databits, 1 stopbit, no parity. Please note this is our expectation: If<br />
the box is configured for something else than 19200 Baud, we will fail or<br />
hang. If 1600 samples/sec are configured instead of 800 sampes/sec, we<br />
won’t care, but timing might be less accurate due to the too high USB load,<br />
unless we’re running on a real serial port which shouldn’t have a<br />
problem with 1600 samples/sec. Serial-over-USB however will likely choke!<br />
Verify that the DIP switches or jumpers inside the box are properly set<br />
up.</p>
<p>‘forpserial-1’ - Connect to a fORP interface unit type FIU-005 on the<br />
serial port, configured with a program switch setting of 1. This is<br />
exactly the same as a PST box running with 800 Samples/Sec streaming<br />
rate.</p>
<p>‘forpserial-0’, ‘forpserial-2’, ‘forpserial-4’, ‘forpserial-6’<br />
Connect to a fORP interface unit type FIU-005 on the serial port,<br />
configured with a program switch setting of 0, 2, 4 or 6. In this mode,<br />
similar to the Bitwhacker, the device will only send a single byte if the<br />
status of the buttons or triggers changes. This is more efficient than<br />
mode ‘forpserial-1’, so one of these settings is recommended.</p>
<p>Modes 0, 4 and 6 will only report button presses or trigger reception,<br />
but not button releases, whereas mode 2 will report any status change,<br />
ie., it will also report and timestamp button releases. The mapping of<br />
the returned status value to corresponding button / trigger states is<br />
dependent on the selected mode. Modes 0, 4 and 6 report ASCII codes that<br />
identify the pressed button, whereas mode 2 returns a status byte where<br />
each bit encodes the current (updated) status of a single button, similar<br />
to the PST and CMU response boxes. For the specifics, see the fORP manual<br />
at http://www.curdes.com/<a href="ForpUserGuide" class="uri">ForpUserGuide</a>.html</p>
<p>‘rtbox’ - Connect to a <a href="RTBox" class="uri">RTBox</a> in “simple mode”, the mode it uses after<br />
powerup. The Box will send a byte of data for each event, each bit encoding<br />
the new status of one button or other input.</p>
<p>‘lumina’ - Connect to a Cedrus Lumina response box.</p>
<p><a href="CMUBox" class="uri">CMUBox</a>(‘<a href="Close" class="uri">Close</a>’, handle);<br />
- <a href="Close" class="uri">Close</a> connection to response box ‘handle’. The ‘handle’ is invalid<br />
thereafter.</p>
<p>evt = <a href="CMUBox" class="uri">CMUBox</a>(‘GetEvent’, handle [, waitForEvent=0]);<br />
- Retrieve next queued event received from the box in the struct ‘evt’.<br />
If no new events are available and the optional ‘waitForEvent’ is set to<br />
1, then the function will wait until at least one valid event becomes<br />
available and return that event. Otherwise it will return an empty struct,<br />
ie., evt = [] to signal that no new events are available.</p>
<h3 id="the-following-subfields-are-available-in-evt-if-evt-is-non-empty">The following subfields are available in ‘evt’ if ‘evt’ is non-empty:</h3>
<p>evt.state = 1 Byte value which encodes the new status of the response<br />
buttons and input lines of the box. A 1-bit means button pressed/signal<br />
active. A 0-bit means button released/signal inactive. See the<br />
documentation of your box for meaning of the single bits. If you use the<br />
Bitwhacker then evt.state does directly encode the button number of a<br />
pressed button: 0 == All buttons released and all TTL inputs low.<br />
Values 1-7 correspond to a low-&gt;high transition of TTL input pins A1 - A7.<br />
Values 8 and 9 correspond to a button press of onboard buttons “USER” or<br />
“PRG”. Bitwhacker can only report one active button or TTL line at a time.</p>
<p>The fORP device will encode evt.state differently depending on selected<br />
mode, either like a Bitwhacker device or like a CMU/PST response box.</p>
<p>evt.time = Psychtoolbox <a href="GetSecs" class="uri">GetSecs</a>() timestamp of the time when the event<br />
was received from the box. The accuracy depends on the properties of your<br />
serial port device and system load. For a native serial port and a<br />
normally loaded system, you can expect about 1-2 msec delay. For a<br />
Serial-over-USB port, it depends on the converter type and driver<br />
settings but can be 2-3 msecs at best.</p>
<p>evt.trouble = If zero, then evt is probably valid and good. If non-zero,<br />
then the timestamp is likely screwed and useless, as are probably all<br />
following timestamps, at least for CMU/PST boxes and fORP’s in mode 1!<br />
For the Bitwhacker or fORP’s in modes 0,2,4 or 6, only the current ‘evt’<br />
will be invalid, but later events will recover and thereby be unaffected.</p>
<p>status = <a href="CMUBox" class="uri">CMUBox</a>(‘Status’, handle);<br />
- Retrieve internal status of response box ‘handle’ as a struct.</p>
<div class="code_header" style="text-align:right;">
<p><span style="float:left;">Path  </span> <span class="counter">Retrieve <a href=
  "https://raw.github.com/Psychtoolbox-3/Psychtoolbox-3/beta/Psychtoolbox/PsychHardware/CMUBox.m">current version from GitHub</a> | View <a href=
  "https://github.com/Psychtoolbox-3/Psychtoolbox-3/commits/beta/Psychtoolbox/PsychHardware/CMUBox.m">changelog</a></span></p>
</div>
<div class="code">
<p><code>Psychtoolbox/PsychHardware/CMUBox.m</code></p>
</div>
