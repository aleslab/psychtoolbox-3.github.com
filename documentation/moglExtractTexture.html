<h2 id="psychtoolbox-psychglimageprocessing">[[Psychtoolbox]] › [[PsychGLImageProcessing]]</h2>
<p>moglExtractTexture(cmd [, arg1][, arg2][, …]) - “MOGL Video texture extraction”</p>
<p>The algorithm makes heavy use of GPU based image processing for maximum<br />
speed, so it needs at least <a href="NVidia" class="uri">NVidia</a> Geforce 6000 series or ATI Radeon<br />
X1000 series graphics hardware (and any later models or equivalent<br />
hardware) to work. It also needs the PTB imaging pipeline enabled, at<br />
least fast offscreen window support. You do this, e.g., by replacing a<br />
call to …</p>
<p>[win, winRect] = <a href="Screen" class="uri">Screen</a>(‘OpenWindow’, screenid, 0);</p>
<p>… with a call sequence like this …</p>
<p><a href="PsychImaging" class="uri">PsychImaging</a>(‘PrepareConfiguration’);<br />
<a href="PsychImaging" class="uri">PsychImaging</a>(‘AddTask’, ‘General’, ‘UseFastOffscreenWindows’);<br />
[win , winRect] = <a href="PsychImaging" class="uri">PsychImaging</a>(‘OpenWindow’, screenid, 0);</p>
<h1 id="subcommands-their-syntax-meaning">Subcommands, their syntax &amp; meaning:</h1>
<p>[oldflag, oldgain] = moglExtractTexture(‘DebugFlag’, flag [, debugGain]);<br />
- Set debug flag to value ‘flag’. Default is zero. Non-zero values enable<br />
different visualizations that may aid debugging non-working setups. 1 =<br />
Show silhouette buffer, 2 = Show trackbuffer, 3 = Show extracted texture.<br />
A setting of -1 shows the real rendered image. A value of -2 disables any<br />
kind of textual warnings.</p>
<p>The optional ‘debugGain’ parameter must be a 4 component [R G B A] color<br />
vector with modulation gains for the drawn “debug images” - simply to<br />
scale each color channel in intensity to allow for display of values<br />
outside the standard displayable range between zero and one.</p>
<p>context = moglExtractTexture(‘CreateContext’, window, rect, texCoordMin, texCoordMax, texResolution [,zThreshold=Off]);<br />
- Create a “rendercontext” for a single 3D object. Returns a ‘context’<br />
handle to it which needs to be passed in to all other functions as<br />
reference. All following parameters are required and don’t have any<br />
defaults:</p>
<p>‘window’ Handle of masterwindow - The onscreen window used for rendering.<br />
This is not neccessarily the window to which final stimulus will be drawn<br />
to, but it is needed as a “parent” for all ressources.</p>
<p>‘rect’ A Psychtoolbox rectangle [left top right bottom] that describes<br />
the size and shape of the input video texture. This rect must have the<br />
same size as the input video image textures – Lots of internal<br />
calculations depend on this geometry spec!</p>
<p>‘texCoordMin’ Two element vector which contains the minimum texture<br />
coordinate values contained in the 3D scene for x- resp. y-direction.</p>
<p>‘texCoordMax’ Two element vector which contains the maximum texture<br />
coordinate values contained in the 3D scene for x- resp. y-direction.</p>
<p>‘texResolution’ Two element vector which contains the internal resolution<br />
for x- resp. y-direction of the 3D object surface. Higher values mean finer<br />
resolution and less aliasing, but also higher storage requirements and<br />
longer processing times. This defines the size of returned extracted<br />
textures.</p>
<p>‘zThreshold’ Optional zThreshold for occlusion test: By default, it is<br />
10.0 ie. occlusion test disabled. A value between 0.0 and 1.0 will enable<br />
occlusion testing – Texels that would correspond to occluded surface patches are<br />
not extracted. Small numbers (close to zero) make the test more sensitive but<br />
can cause artifacts due to internal numeric roundoff errors. Bigger<br />
numbers (closer to one) make it more robust but less powerful. The<br />
“sweet-spot” depends on your hardware and 3D scene. Empirically a setting<br />
of 0.0001 is a good value for ATI Radeon X1000 series hardware.<br />
The default setting (bigger than 1.0) will disable occlusion test –<br />
“Hidden texels” are not ignored, but updated with bogus extracted texture.</p>
<p>context = moglExtractTexture(‘SetRenderCallback’, context, callbackEvalString);<br />
- Define the ‘eval’ string for this context to be used as rendercallback.<br />
Pass in a Matlab command string (for evaluation via eval() function in the<br />
Workspace of the calling function). This string is called/executed during<br />
each ‘Update’ cycle. It has to contain the code that performs the actual<br />
rendering of the 3D scene or object.</p>
<p>The called rendering code *must not* glClear() the framebuffer or mess<br />
around with alpha-blending state or depth-buffer/depth-test settings, nor<br />
should it bind any shaders! It makes sense to disable any kind of<br />
lighting or texture mapping, as no photorealistic image is rendered, so<br />
it would be a waste of computation time.</p>
<p>context = moglExtractTexture(‘DestroyContext’, context);<br />
- Destroy a processing context, release all of its ressources.</p>
<p>[texBuffer, texId, texTarget] = moglExtractTexture(‘Extract’, context, inputTexture [, newTexture = 0]);<br />
- Perform an ‘Extract’ cycle for given context. A new “3D frame” is rendered<br />
via the rendercallback function, then analysed, to provide the 3D surface<br />
geometry and occlusion info and mapping for texture extraction. This info<br />
is then used to extract pixel color values from the given video input<br />
texture ‘inputTexture’ and the final extracted texturemap is stored<br />
inside an internal texture buffer. A handle to that internal buffer<br />
‘texBuffer’ is returned. The handle is owned by this function! You should<br />
not close or otherwise mess with the provided buffer. You can read the<br />
final texture from it, acquire a temporary <a href="OpenGL" class="uri">OpenGL</a> texture handle to it<br />
for texture mapping, etc. You are even allowed to perform destructive<br />
write informations on the buffer to change its pixel content. But do not<br />
destory and reallocate the buffer, change its size, number of layers,<br />
resolution or any other property! For your convenience, ‘texId’ and<br />
‘texTarget’ also provide standard <a href="OpenGL" class="uri">OpenGL</a> handles to texture id and<br />
target, associated with ‘texBuffer’.</p>
<p>Alternatively you can set the optional flag ‘newTexture’ to a value of 1.<br />
In that case, a new extracted texture ‘texBuffer’ is returned and you own<br />
this texture, ie., you can do with it whatever you want and you are<br />
responsible for releasing the texture via <a href="Screen" class="uri">Screen</a>(‘<a href="Close" class="uri">Close</a>’, texBuffer);<br />
once you are done with it.</p>
<div class="code_header" style="text-align:right;">
<p><span style="float:left;">Path  </span> <span class="counter">Retrieve <a href=
  "https://raw.github.com/Psychtoolbox-3/Psychtoolbox-3/beta/Psychtoolbox/PsychGLImageProcessing/moglExtractTexture.m">current version from GitHub</a> | View <a href=
  "https://github.com/Psychtoolbox-3/Psychtoolbox-3/commits/beta/Psychtoolbox/PsychGLImageProcessing/moglExtractTexture.m">changelog</a></span></p>
</div>
<div class="code">
<p><code>Psychtoolbox/PsychGLImageProcessing/moglExtractTexture.m</code></p>
</div>
