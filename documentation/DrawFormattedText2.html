<h2 id="psychtoolbox-psychbasic">[[Psychtoolbox]] › [[PsychBasic]]</h2>
<p>[nx, ny, textbounds, cache, wordbounds] = <a href="DrawFormattedText2" class="uri">DrawFormattedText2</a>(tstring, key-value pairs)<br />
or:<br />
[nx, ny, textbounds, cache, wordbounds] = <a href="DrawFormattedText2" class="uri">DrawFormattedText2</a>(cache, key-value pairs)</p>
<p>When called with a string, the following key-value pairs are understood:<br />
win [, sx][, sy][, xalign][, yalign][, xlayout][, color][, wrapat][, transform][, vSpacing][, righttoleft][, winRect][, resetStyle][, cacheOnly]<br />
Those enclosed in square braces are optional.</p>
<p>When called with a cache struct, the following optional key-value pair<br />
arguments are accepted:<br />
[, win][, sx][, sy][, xalign][, yalign][, transform][, winRect]</p>
<p>example call:<br />
<a href="DrawFormattedText2" class="uri">DrawFormattedText2</a>(‘test text’, ‘win’,window_pointer,‘baseColor’,[255 0 0])</p>
<p>Draws a string of text ‘tstring’ into Psychtoolbox window ‘win’. Allows<br />
some formatting and precise positioning. Only works with the FTGL-based<br />
text plugin (see help <a href="DrawTextPlugin">DrawTextPlugin)</a>), activate it with<br />
<a href="Screen" class="uri">Screen</a>(‘<a href="Preference" class="uri">Preference</a>’,‘TextRenderer’, 1);<br />
This function is _not_ made to be fast. Test carefully if you want it to<br />
work within a screen refresh if you throw a lot of text at it.</p>
<p>The text string ‘tstring’ may contain newline characters ‘’.<br />
Whenever a newline character ‘’ is encountered, a linefeed and<br />
carriage return is performed, breaking the text string into lines.</p>
<p>The text may also contain the formatting tags listed below. Each tag<br />
changes the formatting of the text from that point onward. Tags do not<br />
need to be closed. At the exit of the function, the state of the font<br />
renderer (font, text size, etc) is reset to the state upon function entry<br />
or the state stored in the cache if drawing from cache.<br />
- &lt;i&gt;: toggles italicization<br />
- &lt;b&gt;: toggles bolding<br />
- &lt;u&gt;: toggles underlining<br />
- &lt;color=colorFmt&gt; switches to a new color<br />
- &lt;font=name&gt; switches to a new font<br />
- &lt;size=number&gt; switches to a new font size<br />
The &lt;i&gt;, &lt;b&gt; and &lt;u&gt; tags toggle whether text is italicized, bolded or<br />
underlined and remain active (possibly until the end of the input string)<br />
until the same &lt;i&gt;, &lt;b&gt; or &lt;u&gt; tag is encountered again.<br />
The &lt;color&gt;, &lt;font&gt; and &lt;size&gt; tags can be provided empty (i.e., without<br />
argument), in which case they cause to revert back to the color, font or<br />
size active before the previous switch. Multiple of these in a row go<br />
back further in history (until start color, font, size is reached).<br />
To escape a tag, prepend it with a slash, e.g., /&lt;color&gt;. If you want a<br />
slash right in front of a tag, escape it by making it a double /:<br />
//&lt;color&gt;. No other slashes should be escaped.<br />
&lt;color&gt;‘s argument can have one of two formats, it can either be a<br />
hexadecimal string (HEX), or a comma-separated floating point array<br />
(FPN). If a HEX input is provided, it should encode colors using a 1, 2,<br />
6 or 8 hexadecimal digit string. If 1 or 2 digits are provided, this is<br />
interpreted as a grayscale value. 6 hexadecimal digits are interpreted as<br />
R, G and B values (2 digits each). 8 digits further includes an alpha<br />
value. Using the HEX values, color values range from 0 to 255. Example:<br />
&lt;color=ff0000&gt; changes the text color to red (ff corresponds to 255). The<br />
FPN format consists of 1, 3 or 4 comma separated floating point color<br />
values (luminance, RGB, or RGBA) that can take on any value, but will be<br />
processed according to the current color settings for the window as<br />
indicated by <a href="Screen" class="uri">Screen</a>(’ColorRange’). Typically, the values provided will<br />
range from 0.0–1.0 per component. Floating point values should include<br />
the decimal point to ensure that single element FPN values are parsed<br />
correctly. Examples: &lt;color=1.,0.,0.&gt; and &lt;color=.5&gt;. If a floating point<br />
value is specified but <a href="Screen" class="uri">Screen</a>(‘ColorRange’) returns 255, indicating 8bit<br />
color values are used for the window, the floating point color values<br />
provided are automatically scaled and rounded to the 0-255 range. If the<br />
HEX format is used but <a href="Screen" class="uri">Screen</a>(‘ColorRange’) returns 1.0, indicating<br />
floating point color values are used for the window, the uint8 color<br />
values are automatically converted to the 0.0-1.0 range.<br />
A size/font command before a newline can change the height of the line on<br />
which it occurs. So if you want to space two words ‘test’ and ‘text’<br />
vertically by white space equivalent to an 80pts line, use:<br />
‘test&lt;size=80&gt;&lt;size&gt;text’. There is an empty line between the two new<br />
lines, and the size=80 says that this line has height of 80pts in the<br />
selected font.</p>
<p>‘sx’ and ‘sy’ provide a location on the screen with respect to which the<br />
textbox is positioned. ‘sx’ and ‘sy’ can be a pixel location provided as<br />
a number. Alternatively, ‘sx’ can also be ‘left’ (default), ‘center’, or<br />
‘right’ signifying the left side, horizontal middle, or right side of the<br />
window rect. ‘sy’ can also be ‘top’ (default), ‘center’, or ‘bottom’<br />
signifying the top, vertical middle, or bottom of the window rect.</p>
<p>‘xalign’ and ‘yalign’ are text strings indicating how the textbox should<br />
be aligned to the screen location provided in ‘sx’ and ‘sy’. For<br />
‘xalign’, ‘left’ (default), signifies that the left of the text’s<br />
bounding box is aligned to the screen location; ‘center’ that the<br />
bounding box is centered on this location; and ‘right’ that the right of<br />
the text’s bounding box is aligned with this location. For ‘yalign’,<br />
‘top’ (default), signifies that the top of the text’s bounding box is<br />
aligned to the screen location; ‘center’ that the bounding box is<br />
centered on this location; and ‘bottom’ that the bottom of the text’s<br />
bounding box is aligned with this location.</p>
<p>‘xlayout’ indicates how each line is positioned horizontally in the<br />
bounding box. If ‘left’ (default), all lines are aligned to the left of<br />
the text’s bounding box; if ‘center’, all lines are centered in the<br />
bounding box; and if ‘right’, all lines are aligned to the right of the<br />
bounding box. Justification options are currently not supported.</p>
<p>‘baseColor’ is the color in which the text will be drawn (until changed<br />
by a &lt;color&gt; format call. This is also the color that will remain active<br />
after invocation of this function.</p>
<p>‘wrapat’, if provided, will automatically break text strings longer than<br />
‘wrapat’ characters into newline separated strings of roughly ‘wrapat’<br />
characters. This is done by calling the <a href="WrapString" class="uri">WrapString</a> function (See ‘help<br />
WrapString’). ‘wrapat’ mode may not work reliably with non-ASCII text<br />
strings, e.g., UTF-8 encoded uint8 strings on all systems. It also does<br />
not necessarily lead to lines of roughly equal length, unless using a<br />
monospace font.</p>
<p>‘transform’ allows transforming the text to be drawn as a whole. The<br />
‘transform’ input is a cell array of key-value parameters, indicating<br />
which transform to do in which order. The following transform are<br />
supported:<br />
‘translate’, [dx dy]: translates text by dx horizontally and dy<br />
vertically<br />
‘flip’, axis : mirrors text horizontally if axis is 1, vertically<br />
if axis is 2, and along both axes if number is 3<br />
(which is equal to a 180 deg rotation)<br />
‘scale’, [sx sy] : scale text horizontally by sx and vertically by sy.<br />
Set to 1 if you want no scaling.<br />
‘rotate’, angle : Rotate text by angle (degrees). Note that for the<br />
PTB screen, a positive rotation is clockwise.<br />
example {‘translate’,[100 0],‘rotate’,45} first translates text by 100<br />
pixels, then rotates it by 45 degree clockwise. Note that the order of<br />
operations is important. The above is equal to<br />
{‘rotate’,45,‘translate’,100*sqrt([2 2])/2}. Advanced note: for <a href="OpenGL" class="uri">OpenGL</a><br />
transform are applied in the reverse order from how they’re specified.<br />
That is not the case for this interface, transform are applied in the<br />
order specified.</p>
<p>The optional argument ‘vSpacing’ sets the spacing between the lines.<br />
Default value is 1.</p>
<p>The optional argument ‘winRect’ allows to specify a [left top right<br />
bottom] rectange, in which the text should be placed etc. By default, the<br />
rectangle of the whole ’win’dow is used.</p>
<p>‘resetStyle’. If true, we reset the base text style to normal before<br />
interpreting formatting commands that are present in the input text<br />
string. If not (false), active text style at function entry is taken into<br />
account when processing style toggle tags</p>
<p>‘cache’. Upon invocation of the function, it provides an optional output<br />
‘cache’. Providing this output back to <a href="DrawFormattedText2" class="uri">DrawFormattedText2</a> instead of the<br />
‘tstring’ input allows direct drawing of the exact same text without all<br />
the preprocessing having to be done again, potentially saving significant<br />
time (and simplifying the call syntax). In this mode, a subset of the<br />
below arguments can be used to, e.g., draw to a different window or<br />
reposition the text. This cache can be generated without any actual<br />
drawing being done by setting the ‘cacheOnly’ argument to true. The cache<br />
is an implementation detail and is subject to change at any time.<br />
When drawing from cache, the text can be repositioned with the ‘sx’,<br />
‘sy’, ‘xalign’, ‘yalign’ and ‘winRect’ inputs described above. If only<br />
‘sx’ and ‘sy’ are provided, these are taken to be offsets to move the<br />
bounding box of the cached text. ‘sx’ and ‘sy’ must be numerical in this<br />
case and cannot be empty. If ‘xalign’ and/or ‘yalign’ are provided,<br />
full-fledged parsing of ‘sx’, ‘sy’, ‘xalign’ and ‘yalign’ is done, same<br />
as during a normal call to <a href="DrawFormattedText2" class="uri">DrawFormattedText2</a>. The bounding box is then<br />
repositioned according to these for inputs. The winRect argument is only<br />
used in this case. It is optional (defaulting to the whole windows), and<br />
works as described above, specifying the rect to which ‘xalign’ and<br />
‘yalign’ apply.</p>
<h3 id="return-variables">Return variables:</h3>
<p>The function returns the new (nx, ny) position of the text drawing cursor<br />
and the bounding rectangle ‘textbounds’ of the drawn string. (nx,ny) can<br />
be used as new start position for connecting further text strings to the<br />
bottom of the drawn text string. Calculation of textbounds is<br />
approximative, so it may give wrong results with some text fonts and<br />
styles on some operating systems, depending on the various settings. The<br />
optional ‘cache’ output argument is discussed above.</p>
<p>When rotating by angles that are not a multiple of 90 degrees, the<br />
bounding box may not be accurate (too large). The returned bounding box<br />
is the rect that tightly fits the rotated original bounding box, not the<br />
box that tightly fits the rotated ink of the letters.</p>
<p>The optional return argument ‘wordbounds’, if assigned in the calling<br />
function, returns a n-by-4 matrix of per-word bounding boxes. Each row<br />
defines a [left,top,right,bottom] rectangle with the bounding box of a<br />
word in the text string, ie. row 1 = first word, row 2 = 2nd word, …<br />
white-space characters delimit single words, as do style changes and line-<br />
feeds, and these delimiters are not taken into account for the bounding box,<br />
ie. they don’t get their own bounding boxes. The white-space separating<br />
successive words is as defined by the function isspace(tstring), or by a<br />
change of text style, color, formatting, etc. Use of ‘wordbounds’ may cause<br />
a significant slow-down in text drawing, so only assign this return argument<br />
if you actually need it. A current limitation is that returned bounding boxes<br />
will be likely incorrect if you apply multiple transformations like ‘scale’<br />
‘rotate’, ‘translate’ and ‘flip’ at once. A single transformation will work,<br />
but multiple ones will cause misplaced per word bounding boxes. If you want<br />
to get proper ‘wordbounds’ when drawing text from the ‘cache’ then you must<br />
assign ‘wordbounds’ already in the <a href="DrawFormattedText2" class="uri">DrawFormattedText2</a>() invocation which<br />
returns the ‘cache’, otherwise bounding boxes might be wrong.</p>
<p>One difference in the return values from this function and<br />
<a href="DrawFormattedText" class="uri">DrawFormattedText</a> is that the new (nx, ny) position of the text drawing<br />
cursor output is the baseline of the text. So to use (nx,ny) as the new<br />
start position for connecting further text strings, you need to draw<br />
these strings with yPositionIsBaseline==true. Another difference is that<br />
the returned textbounds bounding box includes the height of an empty line<br />
at the end if the input string ended with a carriage return.<br />
<a href="DrawFormattedText" class="uri">DrawFormattedText</a> only moved (nx,ny) but did not include the empty line<br />
in the bounding box. The empty line is also taken into account when<br />
centering text</p>
<h3 id="further-notes">Further Notes:</h3>
<p>Please note that while positioning and bounding boxes are pixel accurate<br />
with the fonts tested during development, i cannot guarantee this is the<br />
case with all fonts you throw at it. Also note that this function is not<br />
made to be fast. It has a make draw from cache mode so that all<br />
preprocessing is done only once and stored in a cache from which the text<br />
can be drawn directly. Nonetheless, especially if you throw a lot of<br />
formatting at it, this function may still not be fast in this mode. Use<br />
with caution in timing critical paths (test and measure to know if its<br />
fast enough). That said, with reasonable inputs it should manage to draw<br />
text to screen well within the inter frame interval of most screens.</p>
<p>The function employs clipping by default. Text lines that are detected as<br />
laying completely outside the ‘win’dow or optional ’winRect’ will not be<br />
drawn, but clipped away. This allows to draw multi-page text (multiple<br />
screen heights) without too much loss of drawing speed. If you find the<br />
clipping to interfere with text layout of exotic texts/fonts at exotic<br />
sizes and formatting, you can define the global variable…<br />
global ptb_drawformattedtext2_disableClipping;<br />
… and set it like this …<br />
ptb_drawformattedtext2_disableClipping = 1;<br />
… to disable the clipping.</p>
<p>Regardless of the clipping setting, the optional 3rd return parameter<br />
‘textbounds’ always covers the complete text.</p>
<p>See <a href="DrawFormattedText2Demo" class="uri">DrawFormattedText2Demo</a> for a usage example.</p>
<div class="code_header" style="text-align:right;">
<p><span style="float:left;">Path  </span> <span class="counter">Retrieve <a href=
  "https://raw.github.com/Psychtoolbox-3/Psychtoolbox-3/beta/Psychtoolbox/PsychBasic/DrawFormattedText2.m">current version from GitHub</a> | View <a href=
  "https://github.com/Psychtoolbox-3/Psychtoolbox-3/commits/beta/Psychtoolbox/PsychBasic/DrawFormattedText2.m">changelog</a></span></p>
</div>
<div class="code">
<p><code>Psychtoolbox/PsychBasic/DrawFormattedText2.m</code></p>
</div>
