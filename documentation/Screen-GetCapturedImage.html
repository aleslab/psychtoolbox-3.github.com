<h1 id="screengetcapturedimage"><a href="Screen-GetCapturedImage">Screen(‘GetCapturedImage’)</a></h1>
<h2 id="psychtoolbox-screen.mexdll-subfunction">[[Psychtoolbox]] › [[Screen]].{mex*,dll} subfunction</h2>
<p>Try to fetch a new image from video capture device ‘capturePtr’ for visual<br />
playback/display in window ‘windowPtr’ and return a texture-handle ‘texturePtr’<br />
on successfull completion. ‘waitForImage’ If set to 1 (default), the function<br />
will wait until the image becomes available. If set to zero, the function will<br />
just poll for a new image. If none is ready, it will return a texturePtr of<br />
zero, or -1 if none will become ready because capture has been stopped. Set<br />
‘waitForImage’ = 2 if you just want to get the summed intensity or timestamp of<br />
the image. ‘waitForImage’ = 3 will behave as a setting of 2, but it will only<br />
poll, not block. Note: Settings 2 and 3 will not return textures, therefore the<br />
returned ‘texturePtr’ will always be zero, irrespective of availabilty of new<br />
frames. You’ll have to check the other return arguments for indication that a<br />
frame has arrived, e.g., non-zero summed_intensity.<br />
The setting ‘waitForImage’ = 4 is special: It will not block, nor will it return<br />
any information, but will make sure the capture engine keeps running. This is<br />
useful if you want PTB to perform harddisk recording of video footage in the<br />
background without any need to access information about the capture process or<br />
the actual video data from within Matlab. This is the least ressource consuming<br />
way of doing this.<br />
‘oldTexture’ (if provided) allows you to pass the texture handle of an already<br />
existing texture. Psychtoolbox will reuse that texture by overwriting its<br />
previous image content with the new image, instead of creating a completely new<br />
texture for the new image. Use of this ‘’recycling facility’’ may allow for<br />
higher capture framerates and lower latencies on low-end graphics hardware in<br />
some cases. Providing a value of ‘oldTexture’=0 is the same as leaving it out.<br />
The optional argument ‘specialmode’ allows to request special treatment of<br />
textures. Currently, specialmode = 1 will ask PTB to use GL_TEXTURE_2D textures<br />
instead of other formats. This is sometimes less efficient, unless you want to<br />
do realtime blurring of images. If you set specialmode = 2, then the optional<br />
return value ‘average_intensityOrRawImageMatrix’ will not return the summed<br />
pixel intensity, but a Matlab uint8 or uint16 matrix with the captured raw image<br />
data for direct use within Matlab, e.g., via the image processing toolbox. uint8<br />
matrices return intensities in the range 0 - 255. uint16 matrices for high<br />
bitdepth video capture return 16 bit intensity values in which the most<br />
significant bit (the 16th bit) contains the most significant bit of the cameras<br />
sensor data. This means that if a camera has a sensor that returns less than 16<br />
bit precision, then the least significant bits in the uint16 return values will<br />
be all-zero, e.g., a 12 bit sensor would return uint16 values with the 4 least<br />
significant bits all zero.<br />
If you set ‘specialmode’ = 4 and provide a double-encoded memory pointer in<br />
‘targetmemptr’, then PTB will copy the raw image data into that buffer instead<br />
of returning it as a matrix in the fourth return argument. The buffer is<br />
expected to be of sufficient size, otherwise a crash of Matlab or Octave will<br />
occur (Experts only!).<br />
A ‘specialmode’ == 8 will require high-precision drawing, see the specialFlag ==<br />
2 setting in <a href="Screen" class="uri">Screen</a>(‘MakeTexture’) for a description of its meaning. A<br />
‘specialMode’ == 16 will prevent automatic mipmap-generation for GL_TEXTURE_2D<br />
textures. A ‘specialMode’ == 32 will prevent closing of the texture by a call to<br />
<a href="Screen" class="uri">Screen</a>(‘<a href="Close" class="uri">Close</a>’);<br />
‘capturetimestamp’ contains the system time when the returned image was<br />
captured. This timestamp has been verified to be very precise on Linux with<br />
suitable professional IIDC 1394 firewire cameras when the dc1394 capture engine<br />
is used. The same may be true for OS/X, although this hasn’t been extensively<br />
tested. If other operating systems, capture engines or cameras are used, the<br />
timestamp may become just a rough approximation of unknown precision.<br />
The (optional) return value ‘droppedcount’ contains the number of captured<br />
frames that had to be dropped to keep in sync with realtime or due to internal<br />
shortage of buffer memory. If you didn’t specify the ‘dropFrames’ flag in<br />
<a href="Screen" class="uri">Screen</a>(‘StartVideoCapture’) then it will report the number of pending buffers<br />
which can be fetched, i.e., how many more buffers are queued up for delivery.<br />
The (optional) return value ‘average_intensityOrRawImageMatrix’ contains the<br />
average of all pixel intensity values of all channels of the image - some<br />
measure of overall brightness. The value is normalized to the 0.0 - 1.0 range,<br />
where an all-black image would return 0.0 and an all-white saturated image would<br />
return 1.0. Only query this value if you need it, as its computation requires<br />
extra time.</p>
<p>&lt;&lt;=====See also:===== CloseVideoCapture StartVideoCapture StopVideoCapture GetCapturedImage &lt;&lt;</p>
